<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据恢复</title>
    <link href="/2024/03/11/%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/"/>
    <url>/2024/03/11/%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>由于自己的愚蠢<img src="/img/kuku.png" style="zoom:50%;" />，误用了dd命令，导致硬盘内的数据丢失，其中一小部分被覆盖。</p><p>为了恢复未被覆盖的数据，我进行了一系列的尝试。</p><p>注意：该硬盘为机械硬盘，如果是固态硬盘并不保证以下写的方法有效。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>该硬盘连接到电脑上后，从文件资源管理器进去，是无法看到该硬盘的，只有从硬盘管理进去才可以，如下图所示,磁盘1就是该硬盘</p><img src="/img/cipan.jpg" style="zoom:30%;" /><p>从这可以看出分区表有可能损坏了</p><p>然后我开始尝试了一系列免费的数据恢复软件，如recuva,r.saver,dmde,等</p><h3 id="Recuva"><a href="#Recuva" class="headerlink" title="Recuva"></a>Recuva</h3><p>recuva恢复数据的能力挺强的，但是有一个大问题就是，它要求硬盘是有盘符的可以在文件系统中被找到的，很遗憾，我们的硬盘并不满足这点，所以我只能和它说拜拜。</p><p><a href="https://www.ccleaner.com/zh-cn/recuva"> Recuva官网 </a></p><h3 id="R-saver"><a href="#R-saver" class="headerlink" title="R.saver"></a>R.saver</h3><p>R.saver是俄国的一个数据恢复软件，它可以从物理磁盘处来读取我们的硬盘，但是有一个重要的问题是我看不懂俄文，连翻译都不太好翻，当数据恢复结果出来后，我根本不知道应该按哪个键才是恢复数据到其他硬盘上，于是作罢。</p><p><a href="https://rlab.ru/tools/rsaver.html">R.saver 官网</a></p><h3 id="Dmde"><a href="#Dmde" class="headerlink" title="Dmde"></a>Dmde</h3><p>dmde恢复数据的能力很强，尤其是它可以直接读取我们的硬盘，数据恢复结果出来后，是这样的结果</p><img src="/img/dmde.jpg" style="zoom:33%;" /><p>怎么说呢，相当的混乱，有非常非常多的文件系统，然后我点了一个最大的文件系统8TB进去，得到以下结果</p><img src="/img/dmde1.jpg" style="zoom:27%;" /><p>全是散的文件，而且文件夹数量过多，有大概两万多的文件夹。一个个点恢复不太现实，而且我们并不是要所有的数据，只要2023年的。</p><p>然后我们就想是否可以按照文件修改时间来恢复。然后我们就从原理上考察了这点，参考<a href="https://casesic.github.io/2024/03/11/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">文件系统 - casesic</a>这篇文章，我们发现在原理上这是可行的。</p><p>可以从根目录的 inode 号开始读取，根据读取文件的过程, 寻找所有文件的 inode 号，可以在最后读取该文件的 inode 号时,获取对应文件的建立和状态改变的时间，再依次将文件分类。因此数据恢复理论上可以依据文件修改时间分类</p><p>经过在软件上点击尝试，好像是右键，会弹出来一个按照修改时间排序的选项，我们可以将所有文件夹按照时间从大到小排序，然后将显示2023年的修改时间的文件恢复。</p><p>注意：是恢复到另一块硬盘上。</p><p><a href="https://dmde.com/"> DMDE 官网</a></p><h3 id="其他恢复软件"><a href="#其他恢复软件" class="headerlink" title="其他恢复软件"></a>其他恢复软件</h3><p>除此之外，我还尝试了其他恢复软件，有Qphotorec，这个适用于恢复图片；有testdisk,这个主要采用命令行来恢复；以及非常著名的diskgenius，不过免费版的diskgenius只能扫2GB。</p><p><a href="https://www.cgsecurity.org/wiki/TestDisk_Download">TestDisk&amp;Qphotore</a></p><p><a href="https://www.diskgenius.cn/download.php">DiskGenius官网 </a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当数据发生丢失后，千万不能再往里写入数据，覆盖后的数据是不可能再恢复了。能恢复的数据都是没有被覆盖过的。</p><p>对于使用linux命令对电脑进行操作时一定要慎重，要查明命令会对电脑造成的具体结果，否则就有可能出现我这种情况。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文件系统</title>
    <link href="/2024/03/11/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/03/11/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="文件系统组成"><a href="#文件系统组成" class="headerlink" title="文件系统组成"></a>文件系统组成</h2><p>对于文件系统，主要以Ext4文件系统来说明。</p><p>Ext4 文件系统主要由 <strong>superblock,inode</strong> 和 <strong>data block</strong> 三部分组成。</p><p>但是如果文件系统太大，将所有的 inode 与 data block 放在一起很难管理，因此文件系统在格式化的时候基本上是区分为多个块组（block group），每个块组都有独立的 inode&#x2F;data block&#x2F;super block 系统。</p><h3 id="Data-block"><a href="#Data-block" class="headerlink" title="Data block"></a>Data block</h3><p>是用来放置文件内容数据的地方。</p><p><strong>每个 block 最多只能放一个文件的数据，</strong>若文件太大，会占用多个 block。</p><p>block 的大小为 1k,2k或 4k</p><h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><p>记录了文件的属性和该文件实际数据放在哪几号的 block 内。</p><p>大小为 128bytes 或 256bytes。</p><p>记录的文件属性至少有底下这些:</p><p>1.该文件的存取模式</p><p>2.该文件的拥有者和群组</p><p>3.该文件的容量</p><p><strong>4.该文件建立或状态改变的时间</strong></p><p>5.最近一次的读取时间</p><p>6.最近修改的时间</p><p>7.定义文件特性的旗标(flag)，如 SetUID</p><p>8.该文件真正内容的指向</p><h3 id="Superblock"><a href="#Superblock" class="headerlink" title="Superblock"></a>Superblock</h3><p>记录此文件系统的整体信息，包括</p><p>1.inode 和 block 的总量，使用量，剩余量。</p><p>2.block 和 inode 的大小(block 为 1k,2k,4k)，inode 为 128bytes 或256bytes.</p><p>3.文件系统的挂载时间，最近一次写入数据的时间，最近一次检验磁盘的时间等文件系统的相关信息</p><p>4.根目录的inode号</p><h3 id="其余"><a href="#其余" class="headerlink" title="其余"></a>其余</h3><p>除这三个部分之外还有 block bitmap(用于查询哪些 block 是空的，哪些是占用的）。</p><p>inode bitmap(用于查询使用和未使用的 inode 号码)。</p><p>当建立一个目录时，文件系统会分配一个 inode 和至少一块 block 给该目录，其中,inode 记录目录的相关权限和属性，分配到的那块 block号码；block 则是记录在这个目录下的文件名与该文件名占用的 inode号码。</p><h2 id="读取一个文件的过程"><a href="#读取一个文件的过程" class="headerlink" title="读取一个文件的过程"></a>读取一个文件的过程</h2><p>eg:我想读取&#x2F;etc&#x2F;passwd 这个文件</p><ol><li><p>&#x2F;的 inode：</p><p>在 superblock 中获取根目录的 inode 号,且 inode 规范的权限可以让我们读取该 block 的内容(有 r 和 x)</p></li><li><p>&#x2F;的 block：</p><p>经上个步骤取得 block 的号码，找到该内容有 etc&#x2F;目录的 inode 号码</p></li><li><p>etc&#x2F;的 inode:</p><p>读取 etc&#x2F;的 inode，有 r 和 x 权限，因此可以读取 etc&#x2F;的 block 的内容</p></li><li><p>etc&#x2F;的 block:</p><p>经上个步骤取得 block 的号码，找到该内容有 passwd 文件的 inode 号码</p></li><li><p>passwd 的 inode:</p><p>读取 passwd 的 inode 号，有 r 权限，因此可以读取 passwd 的 block内容</p></li><li><p>passwd 的 block：</p><p>最后将该 block 内容的数据读出来</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>windows_cmd_improved</title>
    <link href="/2024/03/05/windows-cmd-improved/"/>
    <url>/2024/03/05/windows-cmd-improved/</url>
    
    <content type="html"><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>出于对本地windows自带的cmd不好用的厌烦，所以我打算改善下windows的cmd</p><h3 id="艰辛的过程"><a href="#艰辛的过程" class="headerlink" title="艰辛的过程"></a>艰辛的过程</h3><h4 id="1-cmder"><a href="#1-cmder" class="headerlink" title="1.cmder"></a>1.cmder</h4><p>经过查阅各种资料发现，<strong>cmder</strong> 似乎是一个不错的替代品，</p><p><strong>cmder</strong>的下载过程可以参考该链接<a href="https://zhuanlan.zhihu.com/p/642372397">cmder下载参考</a>，特别注意一点，<strong>cmder</strong>已经更换域名了，现在为<a href="cmder.app">cmder官方网站</a></p><p>由于我刚开始不知道，点击原本所提供的网站，结果是金融网站,让我有点震撼，最后还是通过github上cmder的仓库追溯到了正确的网站</p><p>等下载完成后，我对cmd比较迫切的功能就是能够在windows通过linux命令行对文件系统进行一系列操作，以及能用便捷的使用vim编辑文件，第一个功能，<strong>cmder</strong>完成的很好，但是第二个功能使用vim就出现了问题，当我键入如下命令行 <em><strong>vim script.sh</strong></em>,结果出现的却是一片空白，当进入insert模式，也打不出任何字符，关于这个问题我查阅网络，查到的只有回退版本这一个答案，于是我尝试回退了三个版本，结果依旧没有任何改善。</p><p>于是最终没有办法，关于<strong>cmder</strong>我只好选择放弃，如果各位找到了解决办法，请麻烦跟我讲一声，非常感谢</p><p>然后我就开始寻找新的办法</p><h4 id="2-wsl"><a href="#2-wsl" class="headerlink" title="2.wsl"></a>2.wsl</h4><p>wsl是Windows Subsystem for Linux的缩写，它可以允许用户在Windows系统上运行Linux环境。通过wsl，我们可以在Windows系统上直接运行Linux命令行工具和应用程序，而无需安装虚拟机或双启动系统。</p><p>安装连接可参考以下</p><p><a href="https://zhuanlan.zhihu.com/p/337104547">如何在 Windows 10 上安装 WSL 2 - 知乎 (zhihu.com)</a></p><p>接着在本地通过apt -install vim，下载vim就可以得到了</p><p>然后我们想通过ubuntu访问我们C盘和D盘上的文件，可以通过以下命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /mnt/c              <span class="hljs-comment"># c盘</span><br>$ <span class="hljs-built_in">cd</span> /mnt/d              <span class="hljs-comment"># d盘</span><br></code></pre></td></tr></table></figure><p>效果还不错</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数学建模</title>
    <link href="/2023/10/22/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    <url>/2023/10/22/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<img src="/img/D1.webp" style="zoom:30%;" /><blockquote><p>我好困耶</p></blockquote><h3 id="层次分析法-AHP"><a href="#层次分析法-AHP" class="headerlink" title="层次分析法(AHP)"></a>层次分析法(AHP)</h3><h4 id="评价类问题可用打分解决"><a href="#评价类问题可用打分解决" class="headerlink" title="评价类问题可用打分解决"></a>评价类问题可用打分解决</h4><ul><li>pdf 4&#x2F;84</li></ul><h4 id="根据权重表格计算得分"><a href="#根据权重表格计算得分" class="headerlink" title="根据权重表格计算得分"></a>根据权重表格计算得分</h4><ul><li>pdf 10&#x2F;84</li></ul><h4 id="一道引出层次分析法的例题"><a href="#一道引出层次分析法的例题" class="headerlink" title="一道引出层次分析法的例题"></a>一道引出层次分析法的例题</h4><ul><li><p>pdf 13&#x2F;84</p><p>优先选择知网（或者万方、百度学术、谷歌学术等平台）搜索相关的文献</p><p>虫部落‐快搜 ： <a href="https://search.chongbuluo.com/">https://search.chongbuluo.com/</a></p></li></ul><h4 id="层次分析法的思想"><a href="#层次分析法的思想" class="headerlink" title="层次分析法的思想"></a>层次分析法的思想</h4><ul><li>pdf 27&#x2F;84</li><li>用1-9表示重要程度</li><li>判断矩阵  pdf 30&#x2F;84</li><li>一致矩阵：各行各列成倍数关系  pdf 36&#x2F;84</li><li>一致性检验  pdf 39&#x2F;84</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2023/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/10/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<img src="/img/sheep.jpg" style="zoom:40%;" /><blockquote><p>幸福的日子，就是吃饱了撑着去睡觉的日子</p></blockquote><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="使用Linux-Unix的基础命令"><a href="#使用Linux-Unix的基础命令" class="headerlink" title="使用Linux&#x2F;Unix的基础命令"></a>使用Linux&#x2F;Unix的基础命令</h3><h4 id="系统的启动和关闭"><a href="#系统的启动和关闭" class="headerlink" title="系统的启动和关闭"></a>系统的启动和关闭</h4><ul><li><p>系统注册</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 超级用户</span><br><span class="hljs-variable">$ </span>普通用户<br></code></pre></td></tr></table></figure></li><li><p>系统登录</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-number">1.</span>输入用户名<br><span class="hljs-symbol">login:</span>root<br><span class="hljs-number">2.</span>输入用户密码，输入的密码不会在屏幕上显示出来，如果输入的密码有误，提示以下信息<br>login incorrect<br><span class="hljs-symbol">login:</span><br><span class="hljs-number">3.</span>系统显示以下，则说明成功登录<br>[root@localhost root]<span class="hljs-meta">#</span><br></code></pre></td></tr></table></figure></li><li><p>系统退出</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">-键入:<span class="hljs-keyword">exit</span><br>-按:Crtl+D<br>-键入:logout<br></code></pre></td></tr></table></figure></li><li><p>系统关闭</p><p>系统将完整地执行关闭所有进程，释放占用资源，停止运行。</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@localhost</span>/root]<span class="hljs-meta"># shutdown -h now</span><br>[root<span class="hljs-symbol">@localhost</span>/root]<span class="hljs-meta"># halt</span><br>[root<span class="hljs-symbol">@localhost</span>/root]<span class="hljs-meta"># init 0</span><br>[root<span class="hljs-symbol">@localhost</span>/root]<span class="hljs-meta"># poweroff</span><br></code></pre></td></tr></table></figure></li><li><p>系统重启</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">使用reboot命令：reboot<br><br>使用shutdown命令：shutdown -r now<br><br>使用init命令：init <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>shutdown命令</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs subunit">语法:shutdown[flag]&lt;time&gt;[warning message]<br>flag:-r 重启   -h 关机     -k 不关机,只发消息<br><span class="hljs-keyword">time:</span>绝对时间:hh:mm  相对时间: +mm(分钟)   立刻关机:now(=<span class="hljs-string">+0</span>)<br></code></pre></td></tr></table></figure></li><li><p>不能冒然关机的原因</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.Linux系统有一个磁盘缓存区，这个缓存区不是立即将所有数据写入磁盘的，而是隔段时间后，再将数据写入磁盘。因此，随手关掉电源可能会导致缓存没有回写， 磁盘上的文件系统不完整；<br>2.在Linux的多任务系统中，可能有许多程序正置于后台运行，只有通过正确的关机顺序， 才可以保证所有的后台进程都能保存自己的数据。<br></code></pre></td></tr></table></figure></li></ul><h4 id="文件及目录基本操作指令"><a href="#文件及目录基本操作指令" class="headerlink" title="文件及目录基本操作指令"></a>文件及目录基本操作指令</h4><ul><li><p>shell命令特点</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-number">1</span>.命令补齐功能：指当键入的字符足以确定目录中唯一的文件时，只需按<span class="hljs-selector-tag">Tab</span>键就可以自动补齐该文件剩下部分<br><span class="hljs-selector-attr">[root@localhost/root]</span><span class="hljs-selector-id">#hist</span><span class="hljs-selector-attr">[Tab]</span><br>系统自动帮用户完成命令<br><span class="hljs-selector-attr">[root@localhost/root]</span><span class="hljs-selector-id">#history</span><br><span class="hljs-number">2</span><span class="hljs-selector-class">.Linux</span>的命令区分大小写，通常<span class="hljs-selector-tag">Linux</span>的命令是小写的<br></code></pre></td></tr></table></figure></li><li><p>ls命令-list directory contents</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">语法:ls[参数]路径或文件名</span><br><span class="hljs-section">功能:列出文件或子目录的信息</span><br><span class="hljs-section">参数:</span><br><span class="hljs-section">-a:显示所有文件，包括以.开头的隐藏文件</span><br><span class="hljs-section">-l:以长格式显示文件或子目录的信息</span><br><span class="hljs-section">-i:显示每个文件的索引号</span><br><span class="hljs-section">-R:显示目录及下级子目录结构</span><br><span class="hljs-section">-S:以文件大小排序</span><br></code></pre></td></tr></table></figure><p>ls -l</p><img src="/img/C1.png" style="zoom:70%;" /><p>蓝色：目录              浅蓝色：链接文件              绿色：可执行文件          红色：压缩文件         灰色：其他文件</p></li><li><p>pwd - 显示用户所处的当前目录</p></li><li><p>cd目录 - 改变当前目录</p></li><li><p>mkdir命令 - make directories建立目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法:<span class="hljs-built_in">mkdir</span>[参数]目录名<br>参数选项:-p:建立目录时，如果父目录不存在，则此时可以和子目录一起建立,即一次可建立多个目录<br>例子:<br><span class="hljs-built_in">mkdir</span> -p dir2/bak<br>在dir2目录下建立bak目录，如果dir2目录不存在，那么同时建立dir2目录<br><span class="hljs-built_in">mkdir</span> dir2/bak<br>在dir2目录下建立bak目录，这里的dir2目录必须是事先存在的<br></code></pre></td></tr></table></figure></li><li><p>rmdir命令 - remove directories删除目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法:<span class="hljs-built_in">rmdir</span>[参数]目录名<br>参数选项:-p: 一起删除父目录时，父目录下应无其他目录<br>例子:<br><span class="hljs-built_in">rmdir</span> <span class="hljs-built_in">test</span><br>删除当前目录下的<span class="hljs-built_in">test</span>目录。删除目录时，被删除目录下应无子目录或文件存在<br><span class="hljs-built_in">rmdir</span> -p longkey/test<br>删除当前目录下的longkey/test目录。删除目录<span class="hljs-built_in">test</span>时，如果父目录longkey下无其他内容，则一起删除longkey目录<br></code></pre></td></tr></table></figure></li><li><p>cp命令 - copy file拷贝文件</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">语法:<span class="hljs-built_in">cp</span>[<span class="hljs-type">options</span>] sourcefile destfile  将文件复制为另一文件<br>    <span class="hljs-built_in">cp</span>[<span class="hljs-type">options</span>] sourcefile... directory  将数个文件复制到一个目录<br>参数选项: <span class="hljs-literal">-p</span> 保持原始文件属性      <span class="hljs-operator">-f</span> 如果目标文件存在，则覆盖它<br>         <span class="hljs-literal">-i</span> 提示是否覆盖现有的普通目标文件    <span class="hljs-literal">-r</span> <span class="hljs-built_in">R</span>:递归复制目录，包含目录下的各级子目录,<span class="hljs-literal">-R</span>允许拷贝设备结点<br>注意:递归拷贝时，目的目录不能在原目录下。如: <span class="hljs-built_in">cp</span> <span class="hljs-literal">-r</span> //targetdir,会使系统死循环或瘫痪<br>例子:<br><span class="hljs-built_in">cp</span> aaa bbb<br>将文件aaa(已存在)复制，并命名为bbb<br><span class="hljs-built_in">cp</span> *.c Finished<br>将所有c语言程序拷贝至Finished目录中<br></code></pre></td></tr></table></figure></li><li><p>rm命令 - 删除文件或目录</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">语法:<span class="hljs-built_in">rm</span>[-<span class="hljs-type">firR</span>] file/directory<br>参数选项: <span class="hljs-operator">-f</span> 不加提示的删除已存在的文件      <span class="hljs-literal">-i</span> 交互删除     <span class="hljs-literal">-r</span> <span class="hljs-built_in">R</span> 递归删除<br>例子:<br><span class="hljs-built_in">rm</span> <span class="hljs-literal">-i</span> *.c <br>删除所有c语言程序档;删除前逐一询问确认<br><span class="hljs-built_in">rm</span> <span class="hljs-literal">-r</span> Finished<br>将Finished的子目录及子目录的所有文件删除<br></code></pre></td></tr></table></figure></li><li><p>mv命令 - move file移动文件或目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法: <span class="hljs-built_in">mv</span>[-<span class="hljs-keyword">fi</span>] sourcefile... targetdirectory     移动文件到目标目录<br>     <span class="hljs-built_in">mv</span> sourcefile targetfile  文件更名<br>参数选项: -f 不提示         -i:目标文件或目录存在时，提示是否覆盖<br></code></pre></td></tr></table></figure></li><li><p>touch命令 - 生成空文件或修改文件的存取和修改时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法: <span class="hljs-built_in">touch</span>[参数]文件或目录名<br>例子:<br><span class="hljs-built_in">touch</span> *<br>将当前目录下所有文件时间修改为当前系统时间<br><span class="hljs-built_in">touch</span> -d 20050912 <span class="hljs-built_in">test</span> <br>将文件<span class="hljs-built_in">test</span>的时间修改为20050912,-t:后面可以接时间, 格式为 [YYMMDDhhmm]<br><span class="hljs-built_in">touch</span> abc <br>如果abc存在， 则修改为当前系统时间， 如果不存在， 则创建该文件<br></code></pre></td></tr></table></figure></li></ul><h4 id="文件和目录的访问权限"><a href="#文件和目录的访问权限" class="headerlink" title="文件和目录的访问权限"></a>文件和目录的访问权限</h4><ul><li><p>文件访问权限</p><ul><li>读权限:只允许用户读其内容，而禁止对其做任何的更改操作</li><li>写权限：允许用户打开并修改文件</li><li>执行权限：用户将该文件作为一个程序执行</li></ul></li><li><p>目录访问权限</p><ul><li>读权限：可以列出存储在该目录下的文件，即读目录内容列表</li><li>写权限：允许从目录中删除或添加新的文件</li><li>执行权限：允许在目录中查找，并能用cd命令将工作目录转到该目录</li></ul></li><li><p>权限变更</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span>命令<br><span class="hljs-built_in">chown</span>命令<br><span class="hljs-built_in">chgrp</span>命令<br></code></pre></td></tr></table></figure></li></ul><h4 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h4><ul><li><p>ln命令 - make links between file建立链接</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scss">语法：ln <span class="hljs-selector-attr">[–s]</span> 目标 链接名   (目标：源文件或目录)<br>参数：<br>-s：建立符号链接(软链接symbolic link) <br>    不加-s参数：建立硬链接(hard link)<br>功能：该命令在文件之间创建链接。这种操作实际上是给系统中已有的某个文件指定另外一个可用于访问它的名称。<br>•建立硬链接时，链接文件和被链接文件必须位于同一个文件系统中。而对符号链接，则不存在这个问题。<br></code></pre></td></tr></table></figure></li><li><p>硬链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">硬连接指通过索引节点来进行的连接。在Linux的文件系统中，保存在磁盘分区中的文件给它分配一个编号，称为索引节点号(Inode Index)。</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">在Linux中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。</span><br>只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放<br></code></pre></td></tr></table></figure></li><li><p>软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">符号连接（Symbolic Link），也叫软链接。软链接文件有点类似于Windows的快捷方式。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">如果[链接名]已经存在但不是目录，将不做链接。[链接名]可以是任何一个文件名（可包含路径），也可以是一个目录，并且允许它与“目标”不在同一个文件系统中。</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">例：$ <span class="hljs-built_in">ln</span> - s study /home/learn</span><br>为当前目录下的文件study创建了一个符号链接/home/learn。<br></code></pre></td></tr></table></figure></li></ul><h4 id="文件压缩和备份命令"><a href="#文件压缩和备份命令" class="headerlink" title="文件压缩和备份命令"></a>文件压缩和备份命令</h4><ul><li><p>tar命令 - 文件归档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法:tar[参数] 文件或目录名<br>参数:<br>-c: 建立一个.tar文件<br>-v: 列出处理过程中的详细信息<br>-f: 指定新的文件名<br>-x: 解压某个文件<br>-u: 用于将新的文件或目录添加到已经存在的tar归档文件中。如果文件已经存在，则更新它。<br>-z: 用zip命令压缩或用unzip解压<br></code></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">tar -cvf <span class="hljs-keyword">back.tar </span><span class="hljs-keyword">backup</span><br><span class="hljs-keyword"></span>备份<span class="hljs-keyword">backup目录下的所有文件和目录</span><br><span class="hljs-keyword"></span>tar -xvf <span class="hljs-keyword">backup.tar </span><br>将备份<span class="hljs-keyword">backup.tar文件还原</span><br><span class="hljs-keyword"></span>tar -cvzf <span class="hljs-keyword">backup.tar.gz </span><span class="hljs-keyword">backup</span><br><span class="hljs-keyword"></span>备份<span class="hljs-keyword">backup目录下的所有文件和目录，并以zip压缩，命名文件为backup.tar.gz</span><br><span class="hljs-keyword"></span>tar -xzvf <span class="hljs-keyword">backup.tar.gz</span><br><span class="hljs-keyword"></span>将备份<span class="hljs-keyword">backup.tar.gz文件还原</span><br><span class="hljs-keyword"></span>tar -tf <span class="hljs-keyword">backup.tar</span><br><span class="hljs-keyword"></span>列出备份文件<span class="hljs-keyword">backup.tar文件的内容</span><br><span class="hljs-keyword"></span>tar -tzf <span class="hljs-keyword">backup.tar.gz</span><br><span class="hljs-keyword"></span>列出备份文件<span class="hljs-keyword">backup.tar.gz文件的内容</span><br><span class="hljs-keyword"></span>tar -rf <span class="hljs-keyword">backup.tar </span>file1<br>在备份<span class="hljs-keyword">backup.tar的尾部添加文件file1</span><br></code></pre></td></tr></table></figure></li><li><p>常见的压缩工具和解压缩工具</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">压缩工具      解压缩工具       后缀         例<br>compress     uncompress     <span class="hljs-selector-class">.Z</span>       rfell8<span class="hljs-selector-class">.text</span><span class="hljs-selector-class">.Z</span><br>gzip           gunzip       <span class="hljs-selector-class">.gz</span>       textfile. gz<br>zip             unzip       <span class="hljs-selector-class">.zip</span>       pakage<span class="hljs-selector-class">.zip</span><br>一般UNIX系统都可使用compress和uncompress工具例如: <span class="hljs-selector-id">#uncompress</span> file3.Z<br></code></pre></td></tr></table></figure></li></ul><h4 id="文件显示命令"><a href="#文件显示命令" class="headerlink" title="文件显示命令"></a>文件显示命令</h4><ul><li><p>cat命令 - 显示文件内容</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vim">常用用法:<br><span class="hljs-keyword">cat</span> 输入模式，显示用户输入的每一行数据。ctrl+D结束<br><span class="hljs-keyword">cat</span> [-n] <span class="hljs-keyword">file</span> 显示文件的内容，-n可加行号显示<br><span class="hljs-keyword">cat</span> &gt; <span class="hljs-keyword">file</span> 建立简单文本文件，crtl+D结束<br><span class="hljs-keyword">cat</span> file1 file2 ....&gt;fileN  将多个文件集中到一个文件<br><span class="hljs-keyword">cat</span> file1&gt;&gt;file2  连接两个文件<br>参数:<br>-n或 --<span class="hljs-keyword">number</span>    由<span class="hljs-number">1</span>开始对所有输出的行数编号<br>-<span class="hljs-keyword">b</span>或 --<span class="hljs-keyword">number</span>-nonblank   和-n类似，只不过对于空白行不编号<br>-s或 --squeeze-blank  当遇到有连续两行以上的空白行，就代换为一行的空白行<br>例子:<br><span class="hljs-keyword">cat</span> -n textfile1 &gt; textfile2<br>把textfile1的档案内容加上行号后输入textfile2这个档案里<br><span class="hljs-keyword">cat</span> -<span class="hljs-keyword">b</span> textfile1 textfile2 &gt;&gt; textfile3<br>把textfile1和textfile2的档案内容加上行号(空白行不加)之后将内容附加到textfile3<br></code></pre></td></tr></table></figure></li><li><p>more,less命令 - 逐页显示文件内容</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stata">语法: <span class="hljs-keyword">more</span>[-option][<span class="hljs-keyword">file</span>...]<br>常见的用法:<br><span class="hljs-keyword">more</span> <span class="hljs-keyword">file</span> 分屏显示文件的内容<br><span class="hljs-keyword">ls</span> | <span class="hljs-keyword">more</span> 查找相关目录文件<br><span class="hljs-keyword">ls</span> -al | <span class="hljs-keyword">more</span> 详细查找相关信息，文件信息<br>ps -ef | <span class="hljs-keyword">more</span> 查找相关进程信息<br></code></pre></td></tr></table></figure></li><li><p>head命令 - 显示文件的前几行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法:<span class="hljs-built_in">head</span>[参数]文件名<br>参数:<br>-n num:显示文件的前num行<br>-c num:显示文件的前num个字符<br>缺省时，<span class="hljs-built_in">head</span>显示文件的前十行<br>例子:<br><span class="hljs-built_in">head</span> textfile1<br>显示textfile1文件开始的前10行内容<br><span class="hljs-built_in">head</span> -20 textfile2<br>显示textfile2文件开始的前20行内容<br></code></pre></td></tr></table></figure></li><li><p>tail命令 - 显示文件的末尾几行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法:<span class="hljs-built_in">tail</span> [-c number]/[-n number] [file]<br>参数:<br>-c: 后的数字为字节位移，缺省为10<br>-n: 行位移,缺省为10<br>例子:<br><span class="hljs-built_in">tail</span> -n3 hs<br></code></pre></td></tr></table></figure></li><li><p>sort命令 - 将文件的内容排序输出</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">语法: <span class="hljs-built_in">sort</span>[参数]文件列表<br>参数：<br>-r:逆向排序，否则，从小到大排序；<br>-n:按数值排序。否则，关键字以字符串比较大小；<br>-t:指定字段 (域) 分割符。缺省是空格或Tab；<br>-k <span class="hljs-built_in">start</span> [, <span class="hljs-keyword">end</span>]:限定关键字。. Start和<span class="hljs-keyword">end</span>格式m[.n],默认从<span class="hljs-number">1</span>开始， <span class="hljs-keyword">end</span>缺省到行尾。m字段号， n字符号。<br>如-k <span class="hljs-number">2.5</span>，<span class="hljs-number">2.9</span> 表示指定以第二字段的第<span class="hljs-number">5</span>个字符至第<span class="hljs-number">9</span>个字符为关键字。<br></code></pre></td></tr></table></figure></li><li><p>uniq命令 - 比较相邻的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">语法:<span class="hljs-built_in">uniq</span>文件名<br>例子:<br><span class="hljs-built_in">uniq</span> b.txt<br>注意:该命令只是去掉相邻的重复行，不相邻的行并不被过滤,<span class="hljs-built_in">uniq</span>常和<span class="hljs-built_in">sort</span>一起使用<br>例如: <span class="hljs-built_in">sort</span> b.txt |<span class="hljs-built_in">uniq</span><br></code></pre></td></tr></table></figure></li><li><p>file命令 - 显示文件或目录</p><p>语法:file 文件名或目录</p></li></ul><h4 id="进程管理的命令"><a href="#进程管理的命令" class="headerlink" title="进程管理的命令"></a>进程管理的命令</h4><ul><li><p>ps命令－查看系统中正在运行的进程</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">语法：ps<span class="hljs-selector-attr">[-ef]</span><span class="hljs-selector-attr">[-n name]</span><span class="hljs-selector-attr">[-t ttys]</span><span class="hljs-selector-attr">[-p pids]</span> <span class="hljs-selector-attr">[-u users]</span><span class="hljs-selector-attr">[-groups]</span><br>参数：<br>-f：产生某个进程的一个完整清单<br>-u：显示进程的用户名和启动时间等信息<br>-t n：显示第n个终端的进程<br>-e：显示所有的进程<br>说明：ps可查看后台进程、前台进程，当ps命令行没有选项时，只显示与控制终端相关进程的基本信息。没有root权限，ps仅限以说明运行进程，报告用户的进程讯息。<br></code></pre></td></tr></table></figure><img src="/img/s8.png" style="zoom:50%;" /></li><li><p>kill命令 - 给进程发送信号</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cos">语法：<span class="hljs-keyword">kill</span> [参数] [进程<span class="hljs-number">1</span>的PID 进程<span class="hljs-number">2</span>的PID…]<br>参数：-<span class="hljs-keyword">s</span> signal：signal是信号类别，如SIGKILL<br><span class="hljs-keyword">kill</span> -<span class="hljs-keyword">l</span> ：显示<span class="hljs-keyword">kill</span>命令所能发送的信号种类，每个信号都有一个数值对应。如：<br>编号    名字       含义<br><span class="hljs-number">1</span>     SIGHUP  挂起<br><span class="hljs-number">2</span>     SIGINT  中断(对前台进程中断)<br><span class="hljs-number">9</span>     SIGKILL  中止 (不可捕捉和忽略，强行消亡)<br><span class="hljs-number">15</span>    SIGTERM  从<span class="hljs-keyword">kill</span>来的软件中断信号（默认）<br>该信号将通知进程退出。如果进程不接受该信号，可<br>以通过参数 –<span class="hljs-number">9</span> 强行结束进程。<br>使用:<br>从另一终端登录，ps -u loginname查找要杀死进程的PID。<br><span class="hljs-keyword">kill</span> PID杀死进程。<br><span class="hljs-keyword">kill</span> -<span class="hljs-number">9</span> pid更有效，但使被杀死的进程不能关闭它正在使用的任何文件。<br><span class="hljs-symbol">^C</span>/<span class="hljs-symbol">^D</span>/Del也可以向进程发中断信号。建议首先使用<span class="hljs-keyword">kill</span> pid。<br></code></pre></td></tr></table></figure></li><li><p>top命令－实时监控进程状况</p><p> top屏幕自动每5秒刷新一次，也可以用top –d 20，使得top屏幕每20秒刷新一次。</p></li><li><p>jobs命令 - 查看当前shell下正在运作的作业</p></li><li><p>sleep命令 - 进程睡眠</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gauss">使当前正在执行的进程在规定的时间内处于睡眠。<br><span class="hljs-built_in">sleep</span>的参数为进程将睡眠的时间，单位为秒。<br>例如： <span class="hljs-built_in">sleep</span> <span class="hljs-number">300</span><br><span class="hljs-number">5</span>分钟后才能出现<span class="hljs-built_in">shell</span>提示符<br></code></pre></td></tr></table></figure></li></ul><h4 id="一些注意点"><a href="#一些注意点" class="headerlink" title="一些注意点"></a>一些注意点</h4><ul><li><p>变址寻址</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">变址寻址是一种寻址方式，它可以根据变址寄存器的内容和指令中的形式地址来计算出操作数的有效地址。变址寻址的优点是可以实现动态的地址变化，从而实现数组、表、栈等数据结构的访问。变址寻址的缺点是需要额外的变址寄存器，而且变址寄存器的内容不能超过指令地址码的位数。<br>变址寻址的一般格式是：<br>EA=R+<span class="hljs-keyword">A</span><br>其中，EA 是有效地址，R 是变址寄存器的内容，<span class="hljs-keyword">A</span> 是指令中的形式地址。<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ps</title>
    <link href="/2023/10/11/ps/"/>
    <url>/2023/10/11/ps/</url>
    
    <content type="html"><![CDATA[<blockquote><p>风是透明的河流，雨是冰凉的流星</p></blockquote><h3 id="Photoshop"><a href="#Photoshop" class="headerlink" title="Photoshop"></a>Photoshop</h3><h4 id="移动工具"><a href="#移动工具" class="headerlink" title="移动工具"></a>移动工具</h4><p>移动工具可以多文件间拖拽图层对象</p><p><a href="https://www.bilibili.com/video/BV187411Z7bx?p=10&vd_source=88b25d8f9cdf683ae7730d67f08b0488">bilili移动工具视频</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">快捷键V<br>文档大小相同，开始拖动后，按下<span class="hljs-built_in">shift</span>,可保持原位<br>移动工具状态下，按住ctrl键快速切换自动选择模式<br>移动工具状态下，组合alt键，可以复制图层<br>组合<span class="hljs-built_in">shift</span>键，约束角度<br>方向键可以微调，组合<span class="hljs-built_in">shift</span>键，步偿加大<br>方向键结合alt键是复制图层<br>选中显示变换控件，就能对图层对象进行变换<br></code></pre></td></tr></table></figure><h4 id="选区"><a href="#选区" class="headerlink" title="选区"></a>选区</h4><p>在对图像进行编辑时，要对图层中某部分的像素进行处理，要把这部分单独选择出来，这个部分叫做选区</p><p>虚线空间以内是我们选择的区域，选区内的像素可被编辑，可被移动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">快捷键M<br>组合<span class="hljs-built_in">shift</span>键，画出正方形选区<br>鼠标进入选区变成白箭头，可以移动选区<br>ctrl+D取消选区，ctrl+<span class="hljs-built_in">shift</span>+D重新选择<br>选区是暂时性的，只有保存选区后才能被存储到PSD文件 右键保存选区<br></code></pre></td></tr></table></figure><p>选区的组合方式</p><ul><li>新选区(每次保留新的选区，而放弃旧的选区)</li><li>添加到选区(新选区和旧选区是并存的)</li><li>从选区减去(把选区一块块去掉)</li><li>与选区交叉(留下交叉的部分)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">在新选区模式下按中<span class="hljs-built_in">shift</span>键切换到添加到选区模式<br>在新选区模式下按中alt键切换到从选区减去模式<br>在新选区模式下按中<span class="hljs-built_in">shift</span>+alt键切换到与选区交叉模式<br>alt键点击选框图标，切换不同的选框工具<br></code></pre></td></tr></table></figure><p>羽化使选区边缘柔和过渡</p><p>样式：固定大小，固定比例</p><h4 id="套索和魔棒工具"><a href="#套索和魔棒工具" class="headerlink" title="套索和魔棒工具"></a>套索和魔棒工具</h4><ul><li><p>套索工具：作出不规则的选区，以及根据图像的轮廓边缘智能地快速的建立选区</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff">快捷键L<br><span class="hljs-deletion">-多边套索工具，可以用backspace或delete键删除刚刚的点，使用时通过ctrl+,ctrl-,空格来放大，缩小，移动图片，</span><br>ctrl+shift+j,剪切掉选择的区域<br><span class="hljs-deletion">-磁性套索工具:磁性套索的控点可以智能识别像素的边缘</span><br></code></pre></td></tr></table></figure></li><li><p>魔棒工具：可以快速地将颜色相近的区域变成选区</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">快捷键w<br>色彩范围的用法和魔棒工具相同<br></code></pre></td></tr></table></figure></li><li><p>快速选择工具：非常重要的抠图工具</p></li></ul><h4 id="选区变形"><a href="#选区变形" class="headerlink" title="选区变形"></a>选区变形</h4><p>画好选区后，右键变换选区，可以改变选区的大小和比例</p><p>选区中的常用命令：反向</p><p>羽化可以制作出边缘比较柔和的选区</p><p>新建图层，填充前景色，快捷键alt+delete</p><p>建立工作路径：选区可以转化为路径</p><p>选择-&gt;修改-&gt;扩展和收缩:对选区进行周边缩放</p><p>选择-&gt;修改-&gt;平滑：可以平滑尖角</p><h4 id="历史记录"><a href="#历史记录" class="headerlink" title="历史记录"></a>历史记录</h4><p>窗口-&gt;历史记录-&gt;历史记录面板</p><p>ctrl+z：返回上一步</p><p>创建快照：可以保证该记录不会被代替掉</p><p>创建历史文档</p><p>历史记录画笔：起到了恢复原始图片区域的作用(快捷键Y)</p><h4 id="画笔工具"><a href="#画笔工具" class="headerlink" title="画笔工具"></a>画笔工具</h4><p>就是在画面上直接进行绘制</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean">快捷键B<br>shift键可画出直线，或连接两个点成一条直线<br>画笔状态下按下alt键，拾取颜色，吸取当前颜色，改变前景色<br>鼠标右击快捷召唤出画笔预设选择器<br>alt加鼠标右键水平移动，画笔变大变小<br>alt加鼠标右键垂直移动，画笔变硬变软<br>编辑-&gt;定义画笔预设:可以自定义画笔<br>存储笔刷文件:面板菜单-&gt;存储画笔<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/2023/10/03/%E7%AE%97%E6%B3%95/"/>
    <url>/2023/10/03/%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<img src="/img/kid.png" style="zoom: 33%;" /><blockquote><p>我本无意穿堂风，偏偏孤倨引山洪</p></blockquote><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h3 id="渐进符号"><a href="#渐进符号" class="headerlink" title="渐进符号"></a>渐进符号</h3><h4 id="O-表示上界"><a href="#O-表示上界" class="headerlink" title="O(表示上界)"></a>O(表示上界)</h4><ul><li><p>定义</p><ol><li>对于给定的函数g(n),O(g(n))表示以下函数的集合：</li></ol><p>​       O(g(n))&#x3D;{T(n):存在c,n0&gt;0,使得任意n&gt;&#x3D;n0，T(n)&lt;&#x3D;cg(n)}</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">严格意义上来讲，f(n) = <span class="hljs-constructor">O(<span class="hljs-params">g</span>(<span class="hljs-params">n</span>)</span>)中的等号=是不对称的,<br>即不能从右边推算到左边。这里表达的意思是属于某个集合<br>即相当于f(n) ∈ <span class="hljs-constructor">O(<span class="hljs-params">g</span>(<span class="hljs-params">n</span>)</span>)。<br></code></pre></td></tr></table></figure><img src="/img/S2.png" style="zoom:50%;" /></li><li><p>例子</p><p>可以把符号O当做宏来用</p><p>f(n)&#x3D;n^3+O(n^2)</p><p>即存在一个h(n)∈O(n^2)，使得f(n)&#x3D;n^3+h(n)</p><p>n^2+O(n)&#x3D;O(n^2)</p><p>表示对于任意的f(n)∈O(n),存在h(n)∈O(n^2),使得n^2+f(n)&#x3D;h(n)。但是反之并不成立</p></li></ul><h4 id="Ω-表示下界）"><a href="#Ω-表示下界）" class="headerlink" title="Ω(表示下界）"></a>Ω(表示下界）</h4><ul><li><p>定义</p><p>对于给定的函数g(n),Ω(g(n))表示以下函数的集合：</p><p> Ω(g(n))&#x3D;{T(n):存在c,n0&gt;0,使得任意n&gt;&#x3D;n0，T(n)&gt;&#x3D;cg(n)}</p><img src="/img/S3.png" style="zoom:50%;" /></li></ul><h4 id="Θ-表示渐进紧确界"><a href="#Θ-表示渐进紧确界" class="headerlink" title="Θ(表示渐进紧确界)"></a>Θ(表示渐进紧确界)</h4><ul><li><p>定义</p><ol><li>对于给定的函数g(n),Θ(g(n))表示以下函数的集合：</li></ol><p>​       Θ(g(n))&#x3D;{T(n):存在c1,c2,n0&gt;0,使得任意n&gt;&#x3D;n0，c1g(n)&lt;&#x3D;T(n)&lt;&#x3D;c2g(n)}</p><ol start="2"><li>Θ(g(n)) &#x3D; O(g(n)) ∩ Ω(g(n))</li></ol><img src="/img/S1.png" style="zoom:50%;" /></li></ul><h3 id="解递归问题"><a href="#解递归问题" class="headerlink" title="解递归问题"></a>解递归问题</h3><h4 id="代换法"><a href="#代换法" class="headerlink" title="代换法"></a>代换法</h4><ul><li><p>进行猜测</p></li><li><p>然后通过数学归纳法证明和解出(常数是不会变化的)</p></li><li><p>例子</p><ul><li><p>T(n)&#x3D;4T(n&#x2F;2)+n，也可以通过类似的方法得到下界和渐进紧确界，这里只展示上界的证明过程</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs excel">猜测 <span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>)=O(<span class="hljs-built_in">n</span>^<span class="hljs-number">3</span>)<br>假设 <span class="hljs-built_in">T</span>(k)&lt;=c(K^<span class="hljs-number">3</span>),对于k&lt;<span class="hljs-built_in">n</span><br><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>)=<span class="hljs-number">4</span><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>)+<span class="hljs-built_in">n</span><br>&lt;=<span class="hljs-number">4</span>c((<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>)^<span class="hljs-number">3</span>)+<span class="hljs-built_in">n</span><br>=<span class="hljs-number">1</span>/<span class="hljs-number">2</span>c(<span class="hljs-built_in">n</span>^<span class="hljs-number">3</span>)+<span class="hljs-built_in">n</span><br>=c(<span class="hljs-built_in">n</span>^<span class="hljs-number">3</span>)-(<span class="hljs-number">1</span>/<span class="hljs-number">2</span>c(<span class="hljs-built_in">n</span>^<span class="hljs-number">3</span>)-<span class="hljs-built_in">n</span>)&lt;c(<span class="hljs-built_in">n</span>^<span class="hljs-number">3</span>)<br>证明<span class="hljs-number">1</span>/<span class="hljs-number">2</span>c(<span class="hljs-built_in">n</span>^<span class="hljs-number">3</span>)-<span class="hljs-built_in">n</span>&gt;=<span class="hljs-number">0</span>,即c&gt;=<span class="hljs-number">1</span>,<span class="hljs-built_in">n</span>&gt;=<span class="hljs-number">2</span>时成立<br>这只是一个证明过程，事实上O(<span class="hljs-built_in">n</span>^<span class="hljs-number">2</span>)也成立，但简单的假设<span class="hljs-built_in">T</span>(k)&lt;=c(k^<span class="hljs-number">2</span>)会出现问题，以下是<span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>)=O(<span class="hljs-built_in">n</span>^<span class="hljs-number">2</span>)的证明过程<br>假设 <span class="hljs-built_in">T</span>(k)&lt;=<span class="hljs-symbol">c1</span>(k^<span class="hljs-number">2</span>)-c2k,对于k&lt;<span class="hljs-built_in">n</span><br><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>)=<span class="hljs-number">4</span><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>)+<span class="hljs-built_in">n</span><br>&lt;=<span class="hljs-number">4</span>c1((<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>)^<span class="hljs-number">2</span>)-<span class="hljs-number">4</span>c2(<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>)+<span class="hljs-built_in">n</span><br>=<span class="hljs-symbol">c1</span>(<span class="hljs-built_in">n</span>^<span class="hljs-number">2</span>)-c2n-(-<span class="hljs-number">1</span>+<span class="hljs-symbol">c2</span>)<span class="hljs-built_in">n</span><br>证明(-<span class="hljs-number">1</span>+<span class="hljs-symbol">c2</span>)<span class="hljs-built_in">n</span>&gt;=<span class="hljs-number">0</span>，即<span class="hljs-symbol">c2</span>&gt;=<span class="hljs-number">1</span>,<span class="hljs-built_in">n</span>&gt;=<span class="hljs-number">1</span>成立<br>接着考虑基本情况<span class="hljs-built_in">T</span>(<span class="hljs-number">1</span>)=Θ(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">T</span>(<span class="hljs-number">1</span>)&lt;=<span class="hljs-symbol">c1</span>-<span class="hljs-symbol">c2</span><br>相对于<span class="hljs-symbol">c2</span>，<span class="hljs-symbol">c1</span>足够大成立<br></code></pre></td></tr></table></figure></li></ul></li></ul><h4 id="递归树法"><a href="#递归树法" class="headerlink" title="递归树法"></a>递归树法</h4><ul><li><p>例子</p><ul><li><p>T(n)&#x3D;T(n&#x2F;4)+T(3n&#x2F;4)+n</p><p><img src="/img/S4.png"></p></li><li><p>T(n)&#x3D;T(n&#x2F;4)+T(n&#x2F;2)+n^2</p><img src="/img/A1.jpg" style="zoom:30%;" /></li></ul></li></ul><h4 id="主定理法"><a href="#主定理法" class="headerlink" title="主定理法"></a>主定理法</h4><ul><li><p>限制</p><p>只能用到特定的递归式上</p><p>T(n)&#x3D;aT(n&#x2F;b)+f(n)</p><p>约束条件：a&gt;&#x3D;1,b&gt;1</p><p>f(n)渐进趋正，表示存在某特定n0，当n&gt;n0时，f(n)大于0</p></li><li><p>过程</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl">比较  <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-variable">n</span>)     <span class="hljs-variable">n</span>^(<span class="hljs-variable">logba</span>)</span><br><span class="hljs-variable">case</span> 小于: <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-variable">n</span>)=<span class="hljs-title">O</span>(<span class="hljs-variable">n</span>^((<span class="hljs-variable">logba</span>)-ε))  ε&gt;<span class="hljs-number">0</span> -&gt; <span class="hljs-title">T</span>(<span class="hljs-variable">n</span>)=Θ(<span class="hljs-variable">n</span>^(<span class="hljs-variable">logba</span>))</span><br><span class="hljs-variable">case</span> 等于: <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-variable">n</span>)=Θ(<span class="hljs-variable">n</span>^(<span class="hljs-variable">logba</span>)(<span class="hljs-variable">log2n</span>)^<span class="hljs-variable">K</span>)  <span class="hljs-variable">k</span>&gt;=<span class="hljs-number">0</span> -&gt; <span class="hljs-title">T</span>(<span class="hljs-variable">n</span>)=Θ(<span class="hljs-variable">n</span>^(<span class="hljs-variable">logba</span>)(<span class="hljs-variable">log2n</span>)^(<span class="hljs-variable">k</span>+<span class="hljs-number">1</span>))</span><br><span class="hljs-variable">case</span> 大于: <span class="hljs-function"><span class="hljs-title">f</span>(<span class="hljs-variable">n</span>)=Ω(<span class="hljs-variable">n</span>^((<span class="hljs-variable">logba</span>)+ε)) ε&gt;<span class="hljs-number">0</span> &amp; <span class="hljs-title">af</span>(<span class="hljs-variable">n</span>/<span class="hljs-variable">b</span>)&lt;=(<span class="hljs-number">1</span>-ε<span class="hljs-string">&#x27;)f(n) ε&#x27;</span>&gt;<span class="hljs-number">0</span> -&gt; <span class="hljs-title">T</span>(<span class="hljs-variable">n</span>)=Θ(<span class="hljs-title">f</span>(<span class="hljs-variable">n</span>))</span><br></code></pre></td></tr></table></figure></li><li><p>例子</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">T(<span class="hljs-params">n</span>)</span>=<span class="hljs-number">4</span><span class="hljs-constructor">T(<span class="hljs-params">n</span><span class="hljs-operator">/</span>2)</span>+n  n&lt;n^<span class="hljs-number">2</span>  <span class="hljs-constructor">T(<span class="hljs-params">n</span>)</span>=Θ(n^<span class="hljs-number">2</span>)<br><span class="hljs-constructor">T(<span class="hljs-params">n</span>)</span>=<span class="hljs-number">4</span><span class="hljs-constructor">T(<span class="hljs-params">n</span><span class="hljs-operator">/</span>2)</span>+n^<span class="hljs-number">2</span>  n^<span class="hljs-number">2</span>=n^<span class="hljs-number">2</span> <span class="hljs-constructor">T(<span class="hljs-params">n</span>)</span>=Θ((n^<span class="hljs-number">2</span>)log2n)<br><span class="hljs-constructor">T(<span class="hljs-params">n</span>)</span>=<span class="hljs-number">4</span>(T/<span class="hljs-number">2</span>)+n^<span class="hljs-number">3</span>  <span class="hljs-constructor">T(<span class="hljs-params">n</span>)</span>=Θ(n^<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure></li></ul><h3 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h3><ul><li><p>定义</p><ul><li>Divide(把一个问题分成多个子问题,并且这些子问题在一定程度上更小了)</li><li>Conquer(递归的解决每一个子问题)</li><li>Combine(把多个子问题的解合并成大问题的解)</li></ul></li><li><p>注意</p><ul><li>子问题是相互独立的</li><li>若不独立，将重复计算</li></ul></li><li><p>例子</p><ul><li><p>归并排序(merge sort)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">    <span class="hljs-number">1</span>.将待排序的数组一分为二<br>    <span class="hljs-number">2</span>.递归地对每个子数组进行排序<br><span class="hljs-number">3</span>.通过双指针合并<br>    <span class="hljs-built_in">T</span>(n)=<span class="hljs-number">2</span><span class="hljs-built_in">T</span>(n/<span class="hljs-number">2</span>)+Θ(n)=Θ(nlgn)  注意：这里lg=log2<br></code></pre></td></tr></table></figure></li><li><p>二分法(binary search)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">你想要找x在一个排列好的数组<br><span class="hljs-number">1</span><span class="hljs-selector-class">.divide</span>,把x与中间值比较，比中间值小在左边，比中间值大在右边<br><span class="hljs-number">2</span><span class="hljs-selector-class">.Conquer</span>,只在一个子数组递归<br><span class="hljs-number">3</span><span class="hljs-selector-class">.combine</span>,没有必要，找到就行<br><span class="hljs-function"><span class="hljs-title">T</span><span class="hljs-params">(n)</span></span>=<span class="hljs-built_in">T</span>(n/<span class="hljs-number">2</span>)+Θ(<span class="hljs-number">1</span>)=Θ(lgn)<br></code></pre></td></tr></table></figure></li><li><p>乘方问题</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">计算x的n次方<br>x^n=x^(n/<span class="hljs-number">2</span>)*x^(n/<span class="hljs-number">2</span>)   n是偶数<br>   =x^(n-<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)*x^(n-<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)*x  n是奇数<br><span class="hljs-function"><span class="hljs-title">T</span><span class="hljs-params">(n)</span></span>=<span class="hljs-built_in">T</span>(n/<span class="hljs-number">2</span>)+Θ(<span class="hljs-number">1</span>)=Θ(lgn)<br></code></pre></td></tr></table></figure></li><li><p>斐波那契序列</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">F(<span class="hljs-params">n</span>)</span>=<span class="hljs-number">0</span> <span class="hljs-keyword">if</span> n==<span class="hljs-number">0</span><br>     <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span><br>     <span class="hljs-constructor">F(<span class="hljs-params">n</span>-1)</span>+<span class="hljs-constructor">F(<span class="hljs-params">n</span>-2)</span> <span class="hljs-keyword">if</span> n&gt;=<span class="hljs-number">2</span><br><span class="hljs-number">1.</span>简单的递归，<span class="hljs-constructor">F(<span class="hljs-params">n</span>)</span>=Ω(φ^n)  φ为黄金比例<br><span class="hljs-number">2.</span>自下而上的递归，F0，F1，F2，...，Fn    <span class="hljs-constructor">F(<span class="hljs-params">n</span>)</span>=Θ(n)<br><span class="hljs-number">3.</span>朴素平方递归式  <span class="hljs-constructor">F(<span class="hljs-params">n</span>)</span>=φ^n/根号<span class="hljs-number">5</span>=Θ(lgn)，取最近的整数，即为答案   (但现实中计算机并不能完成，涉及到了浮点数的运算)<br><span class="hljs-number">4.</span>平方递归式  <span class="hljs-literal">[F(<span class="hljs-identifier">n</span>-<span class="hljs-number">1</span>) F(<span class="hljs-identifier">n</span>)]</span>=<span class="hljs-literal">[<span class="hljs-number">1</span>  <span class="hljs-number">1</span>]</span> 的n-<span class="hljs-number">1</span>次方 <span class="hljs-constructor">F(<span class="hljs-params">n</span>)</span>=Θ(lgn)<br>            <span class="hljs-literal">[F(<span class="hljs-identifier">n</span>) F(<span class="hljs-identifier">n</span>-<span class="hljs-number">2</span>)]</span> <span class="hljs-literal">[<span class="hljs-number">1</span>  <span class="hljs-number">0</span>]</span>              <br></code></pre></td></tr></table></figure></li><li><p>矩阵乘法</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Input</span>: A=[aij], B=[bij]<br><span class="hljs-attribute">Output</span>: C=[cij]=AB  <br><span class="hljs-attribute">1</span>.n*n矩阵 -&gt; <span class="hljs-number">2</span>*<span class="hljs-number">2</span>矩阵(元素为n/<span class="hljs-number">2</span>*n/<span class="hljs-number">2</span>的子矩阵)   T(n)=<span class="hljs-number">8</span>(n/<span class="hljs-number">2</span>)+Θ(n^<span class="hljs-number">2</span>)=Θ(n^<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><img src="/img/A2.jpg" style="zoom:30%;" /><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">可以通过运算，将<span class="hljs-number">8</span>次<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>*<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>的矩阵相乘降为<span class="hljs-number">7</span>次<br><span class="hljs-symbol">p1</span>=a(f-h)     <span class="hljs-symbol">p2</span>=(a+b)h    <span class="hljs-symbol">p3</span>=(c+d)e   <span class="hljs-symbol">p4</span>=d(g-e)   <span class="hljs-symbol">p5</span>=(a+d)(e+h)    <span class="hljs-symbol">p6</span>=(b-d)(g+h)    <span class="hljs-symbol">p7</span>=(a-c)(e+f)   <br><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>)=<span class="hljs-number">7</span><span class="hljs-built_in">T</span>(<span class="hljs-built_in">n</span>/<span class="hljs-number">2</span>)+Θ(<span class="hljs-built_in">n</span>^<span class="hljs-number">2</span>)=Θ(<span class="hljs-built_in">n</span>^<span class="hljs-symbol">lg7</span>)=Θ(<span class="hljs-built_in">n</span>^<span class="hljs-number">2.81</span>)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li><p>原理</p><ul><li>可分为多个相关子问题</li><li>子问题的解被重复使用</li><li>子问题的解求取一次，结果保存在表中，以后用到时直接存取</li></ul></li><li><p>带有记忆的递归</p></li><li><p>例子</p><ul><li><p>斐波那契序列</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">1.</span>(子问题)subproblem: <span class="hljs-constructor">F(<span class="hljs-params">i</span>)</span>=Fi     <span class="hljs-number">1</span>&lt;=i&lt;=n<br><span class="hljs-number">2.</span>Relate:   <span class="hljs-constructor">F(<span class="hljs-params">i</span>)</span>=<span class="hljs-constructor">F(<span class="hljs-params">i</span>-1)</span>+<span class="hljs-constructor">F(<span class="hljs-params">i</span>-2)</span><br><span class="hljs-number">3.</span>Topological order: increasing i, <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,...n<br><span class="hljs-number">4.</span>base case: <span class="hljs-constructor">F(1)</span>=<span class="hljs-number">1</span>,<span class="hljs-constructor">F(2)</span>=<span class="hljs-number">1</span><br><span class="hljs-number">5.</span>origin problem :<span class="hljs-constructor">F(<span class="hljs-params">n</span>)</span><br><span class="hljs-number">6.</span>time: 呈指数级增长<br></code></pre></td></tr></table></figure><p>自上而下的</p><img src="/img/S5.png" style="zoom:40%;" /><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">Memoizati<span class="hljs-symbol">on:</span>记住并重用子问题的解决方案<br><span class="hljs-built_in">time</span> <span class="hljs-symbol">:</span>Θ(<span class="hljs-built_in">n</span>)<br></code></pre></td></tr></table></figure><p>自下而上的</p><img src="/img/s6.png" style="zoom:40%;" /></li><li><p>DAG(有向无环图)最短路径问题</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">给出有向无环图G和点s,计算<span class="hljs-constructor">S(<span class="hljs-params">s</span>,<span class="hljs-params">v</span>)</span>对于任意的v∈V<br>-subproblem:  <span class="hljs-constructor">S(<span class="hljs-params">s</span>,<span class="hljs-params">v</span>)</span><br>-relate: <span class="hljs-constructor">S(<span class="hljs-params">s</span>,<span class="hljs-params">v</span>)</span>=min&#123;<span class="hljs-constructor">S(<span class="hljs-params">s</span>,<span class="hljs-params">u</span>)</span>+w(u,v)<span class="hljs-pattern-match">|u∈adj(v)&#125;  (adj(v)的意思是v的邻接列表)</span><br><span class="hljs-pattern-match">-topo order:topo order <span class="hljs-keyword">of</span> <span class="hljs-constructor">G(DAG)</span></span><br><span class="hljs-pattern-match">-base: <span class="hljs-constructor">S(<span class="hljs-params">s</span>,<span class="hljs-params">s</span>)</span>=∅</span><br><span class="hljs-pattern-match">-original: 所有的子问题</span><br><span class="hljs-pattern-match">-time ∑(v∈<span class="hljs-constructor">V</span>)<span class="hljs-constructor">O(1+ADJ(<span class="hljs-params">v</span>)</span>)=<span class="hljs-constructor">O(|E|+|V|)</span></span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">-拓扑排序算法（Topological Sort）：先对有向无环图进行拓扑排序，得到节点的拓扑序列，然后按照拓扑序列的顺序依次计算节点的最短路径。<br>-动态规划算法（Dynamic Programming）：使用动态规划的思想，定义一个数组dp，dp<span class="hljs-selector-attr">[i]</span>表示从起点到节点<span class="hljs-selector-tag">i</span>的最短路径长度。然后按照拓扑序列的顺序依次更新dp数组，直到计算出终点的最短路径。<br>-Dijkstra算法：Dijkstra算法是一种贪心算法，通过维护一个距离数组dist，dist<span class="hljs-selector-attr">[i]</span>表示从起点到节点<span class="hljs-selector-tag">i</span>的最短路径长度。算法从起点开始，依次选择距离最小的节点，并更新其相邻节点的最短路径长度，直到计算出终点的最短路径。<br>-Bellman-Ford算法：Bellman-Ford算法是一种动态规划算法，通过迭代更新节点的最短路径长度。算法首先将起点的最短路径长度设为<span class="hljs-number">0</span>，然后依次更新其他节点的最短路径长度，直到没有路径长度发生变化或者迭代次数达到节点数。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">拓扑排序是一种对有向无环图（DAG）进行排序的算法，它将图中的节点按照一种线性的顺序进行排序，使得对于图中的每一条有向边 (u, v)，节点 u 都排在节点 v 的前面。用入度和出度<br></code></pre></td></tr></table></figure></li><li><p>保龄球问题</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">给n个保龄球(pin)<br>-第<span class="hljs-selector-tag">i</span>个保龄球值vi<br>-击倒<span class="hljs-number">1</span>个保龄球<span class="hljs-selector-tag">i</span>,得到vi个分数<br>-击倒<span class="hljs-number">2</span>个保龄球<span class="hljs-selector-tag">i</span>,<span class="hljs-selector-tag">i</span>+<span class="hljs-number">1</span>,得到vi*v(<span class="hljs-selector-tag">i</span>+<span class="hljs-number">1</span>)分数<br></code></pre></td></tr></table></figure><p>好的子问题：</p><ul><li>前缀  x[ : i]     Θ(n)</li><li>后缀  x[i:  ]     Θ(n)</li><li>子串  x[i: j]     Θ(n^2)</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">subproblem: B(i)=maxscore possible starting with pins i,i<span class="hljs-string">+1</span>...n<span class="hljs-string">-1</span><br>Relate: B(i)=max&#123;B(i<span class="hljs-string">+1</span>),B(i<span class="hljs-string">+1</span>)+vi,B(i<span class="hljs-string">+2</span>)+vi*v(i<span class="hljs-string">+1</span>)&#125;<br>topo order:decreasing i<br>base:B(n)=0<br>original: B(0)<br><span class="hljs-keyword">time:</span> Θ(n)<br></code></pre></td></tr></table></figure></li><li><p>最长公共子序列(LCS)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">H <span class="hljs-selector-tag">I</span> E R O C L Y  <span class="hljs-selector-tag">P</span> H O L O G Y   和  M <span class="hljs-selector-tag">I</span> C H <span class="hljs-selector-tag">A</span> E L <span class="hljs-selector-tag">A</span> N G E L O 给两个序列<span class="hljs-selector-tag">A</span>和<span class="hljs-selector-tag">B</span>，找<span class="hljs-selector-tag">A</span>和<span class="hljs-selector-tag">B</span>最长的公共子序列<br>-subproblem: <span class="hljs-built_in">L</span>(i,j)=<span class="hljs-built_in">LCS</span>(A[i: ],B[j: ])<br>-relate: <span class="hljs-built_in">L</span>(i,j)=if A[i]=B[j]: <span class="hljs-number">1</span>+<span class="hljs-built_in">L</span>(i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>) else:=max&#123;L(<span class="hljs-selector-tag">i</span>+<span class="hljs-number">1</span>,j),L(<span class="hljs-selector-tag">i</span>,j+<span class="hljs-number">1</span>)&#125;<br>-topo: for i=|A|...<span class="hljs-number">0</span>,for j=|B|...<span class="hljs-number">0</span><br>-base: <span class="hljs-built_in">L</span>(|A|,j)=<span class="hljs-number">0</span>,<span class="hljs-built_in">L</span>(i,|B|)=<span class="hljs-number">0</span><br>-original:<span class="hljs-built_in">L</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>-time: Θ(|A|*|B|)<br></code></pre></td></tr></table></figure></li><li><p>最长递增子序列(LIS)</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coq">给出序列A：C A R B O H Y D R A T E  找LIS(A)<br>-subproblem: L(i)=LIS(A[i: ])<br>-relate: L(i)=<span class="hljs-number">1</span>+max&#123;L(j)|<span class="hljs-type">i</span>&lt;=j&lt;|<span class="hljs-type">A</span>|<span class="hljs-type">,A</span>[i]&lt;A[j]&#125;  遍历i到|<span class="hljs-type">A</span>|<span class="hljs-type">之间的j</span><br>-original: max&#123;L(i)|<span class="hljs-type">0</span>&lt;=i&lt;=<span class="hljs-number">1</span>&#125;<br>-topo order: <span class="hljs-keyword">for</span> i=|<span class="hljs-type">A</span>|<span class="hljs-type">...0</span><br>-base: L(|<span class="hljs-type">A</span>|<span class="hljs-type">)=0</span><br>-<span class="hljs-built_in">time</span>: Θ(|<span class="hljs-type">A</span>|<span class="hljs-type">^2</span>)<br></code></pre></td></tr></table></figure></li><li><p>交替硬币游戏</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">给出n个硬币价值为v0,..<span class="hljs-selector-class">.v</span>(n-<span class="hljs-number">1</span>),两个人轮流取最边上的硬币<br>-subproblem:(substring) <span class="hljs-built_in">x</span>(<span class="hljs-selector-tag">i</span>,j,p)=max total value I can get from coins of value vi to vj。p表示你或我<br>-relate:<span class="hljs-built_in">x</span>(<span class="hljs-selector-tag">i</span>,j,me)=max&#123;<span class="hljs-built_in">x</span>(i+<span class="hljs-number">1</span>,j,you)+vi,<span class="hljs-built_in">x</span>(<span class="hljs-selector-tag">i</span>,j-<span class="hljs-number">1</span>,you)+vj&#125;<br>        <span class="hljs-built_in">x</span>(<span class="hljs-selector-tag">i</span>,j,you)=min&#123;<span class="hljs-built_in">x</span>(i+<span class="hljs-number">1</span>,j,me),<span class="hljs-built_in">x</span>(<span class="hljs-selector-tag">i</span>,j-<span class="hljs-number">1</span>,me)&#125;<br>-topo:incr j-<span class="hljs-selector-tag">i</span><br>-base:<span class="hljs-built_in">x</span>(<span class="hljs-selector-tag">i</span>,<span class="hljs-selector-tag">i</span>,me)=vi <span class="hljs-built_in">x</span>(<span class="hljs-selector-tag">i</span>,<span class="hljs-selector-tag">i</span>,you)=<span class="hljs-number">0</span><br>-original:<span class="hljs-built_in">x</span>(<span class="hljs-number">0</span>,n,me)<br>-<span class="hljs-selector-tag">time</span>:Θ(n^<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><img src="/img/S7.png" style="zoom:50%;" /></li><li><p>通过括号最大化计算</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff">给出一个表达式 num1 符号1 ...numN  符号为+或*，添加括号算出最大值<br><span class="hljs-deletion">-idea:猜测哪个运算符是最后</span><br><span class="hljs-deletion">-subproblem: substring</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ul><li><p>图的基本知识</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Digraph <span class="hljs-attribute">G</span>=（V，E)<br><span class="hljs-built_in">set</span> V of vertices<br><span class="hljs-built_in">set</span> E ≤ V*V of edges<br><br>1. (Adjacency matrix)邻接矩阵 of G= (V,E)，<span class="hljs-attribute">V</span>=｛1，2...，n｝,A是一个n*n矩阵,A[i,j]=1,   <span class="hljs-keyword">if</span> （i,j）∈E   ;  A[i,j]=0，<span class="hljs-keyword">if</span> (i,j) 不属于E<br> Θ（V^2）稠密表示<br>2. (Adjacency list)邻接表是adj[v]的集合，adj[v]记录了与v相邻的顶点, v∈A<br> Θ（V+E）稀疏表示法<br></code></pre></td></tr></table></figure></li><li><p>握手定理：如果对任意的图取顶点的度，总度数总是等于边数的两倍</p></li><li><p>最小生成树</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs excel">Inp<span class="hljs-symbol">ut:</span> 有一个连通的无向图G=（V，E），还有一个给边加权的函数w<br>为了更简单，假设所有边的权值都是互异的<br>Outp<span class="hljs-symbol">ut:</span>一棵生成树<span class="hljs-built_in">T</span>连接了所有的顶点，权重的总和还必须最小，w(<span class="hljs-built_in">T</span>)=∑w（u，v），(u,v)∈<span class="hljs-built_in">T</span><br><span class="hljs-built_in">T</span>是图G的最小生成树，<span class="hljs-symbol">G0</span>是一个由<span class="hljs-built_in">T</span>所导出的图G的子图<br>移开<span class="hljs-built_in">T</span>中的一条边，出现两棵树<span class="hljs-symbol">T1</span>和<span class="hljs-symbol">T2</span>，<span class="hljs-symbol">G1</span>是由<span class="hljs-symbol">T1</span>导出的图，<span class="hljs-symbol">G2</span>是由<span class="hljs-symbol">T2</span>导出的图<br>w（<span class="hljs-built_in">T</span>）=w（u，v）十w（<span class="hljs-symbol">T1</span>）十w（<span class="hljs-symbol">T2</span>）<br>贪心算法的特性：一个局部最优解也是全局最优解<br><span class="hljs-built_in">T</span>是G(V,E)的最小生成树，A是V的任意子集，假设边(u,v)是连接着A到A的补集的最小权值的边，那么边(u,v)属于最小生成树<br></code></pre></td></tr></table></figure></li><li><p>Prim算法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">把V-A维护成一个优先队列Q，Q的每一个顶点都赋一个值给它，就是连接A和V-A权值最小的边的权值<br>一开始Q包含了所有的顶点，A设为空集，此时优先队列的所有权值都会被设为正无穷<br>从一个顶点s出发,key[s]=<span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> Q!=∅   <span class="hljs-comment">//当Q不为空集时，</span><br>  <span class="hljs-keyword">do</span> u←<span class="hljs-built_in">ExtractMin</span>(Q)   <span class="hljs-comment">//从Q中取出最小的元素</span><br>     <span class="hljs-keyword">for</span> each v ∈adj[u]<br>         <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> v∈Q <span class="hljs-keyword">and</span> <span class="hljs-built_in">w</span>(v)&lt;<span class="hljs-built_in">key</span>(v)<br>             then key[v]←<span class="hljs-built_in">w</span>(v)<br>time=Θ(V*<span class="hljs-built_in">T</span>(extract_min)+E*<span class="hljs-built_in">T</span>(decrease))<br>Q       <span class="hljs-built_in">T</span>(extract_min)     <span class="hljs-built_in">T</span>(derease_key)     Total<br>array       <span class="hljs-built_in">O</span>(v)                <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)           <span class="hljs-built_in">O</span>(v^<span class="hljs-number">2</span>)<br>binary heap  <span class="hljs-built_in">O</span>(lgv)             <span class="hljs-built_in">O</span>(lgv)         <span class="hljs-built_in">O</span>(Elgv)  <br>Fib heap    <span class="hljs-built_in">O</span>(lgv)              <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)           <span class="hljs-built_in">O</span>(E+vlgv)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h3><ul><li><p>给出一个有向图G&#x3D;(V,E)，边的权重函数w</p><p>路径 p&#x3D;v1-&gt;v2…-&gt;vk,有 w(p)&#x3D;∑w(vi-&gt;vi+1)  (i∈(1,k-1)）</p></li><li><p>我们想求u点到v点的最短路径</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">S</span><span class="hljs-params">(u,v)</span></span>=min&#123;<span class="hljs-built_in">w</span>(p):<span class="hljs-selector-tag">p</span>(路径) from u to v&#125;<br>不存在最短路径的情况:<span class="hljs-number">1</span>.从u到v的路径上存在一个负环，这样可以通过不停地跑负环来减小路径<br>                  <span class="hljs-number">2</span>.一条从u到v的路径都没有<br></code></pre></td></tr></table></figure></li><li><p>三角不等式：对于任意的点，u,v,x∈V，S(u,v)&lt;&#x3D;S(u,x)+S(x,v)</p></li><li><p>Dijkstra算法</p><p>单源最短路径问题：找出从源点s到其他所有点的最短路径问题</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">假设w(u,v)&gt;=<span class="hljs-number">0</span>,对于任意的u,v∈V,最短路径存在<br><span class="hljs-number">1</span>.贪心算法<br>-maintain <span class="hljs-keyword">set</span> S <span class="hljs-keyword">of</span> vertices whose shortest-path distance form s <span class="hljs-keyword">is</span> known<br>-<span class="hljs-keyword">each</span> <span class="hljs-keyword">step</span> <span class="hljs-keyword">add</span> <span class="hljs-keyword">to</span> S the vertice v∈V-S whose distance estimate <span class="hljs-keyword">is</span> mininum<br>-update distance estimate<br>Dijkstra算法<br>d[s]&lt;-<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> v∈V-<span class="hljs-comment">&#123;s&#125;</span><br>   <span class="hljs-keyword">do</span> d[v]←∞<br>S&lt;-∅<br>Q&lt;-V  <span class="hljs-comment">//Q为优先队列</span><br><span class="hljs-keyword">while</span> Q!=∅<br>   <span class="hljs-keyword">do</span> u←Extractmin(Q)<br>   S&lt;-S∪<span class="hljs-comment">&#123;u&#125;</span><br>   <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> v∈adj(u)<br>     <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> d[v]&gt;d[u]+w(u,v)<br>         <span class="hljs-keyword">then</span> d[v]=d[u]+w(u,v)<br></code></pre></td></tr></table></figure></li><li><p>引理</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">suppose s-&gt;...&gt;u-&gt;v is a shortest path<br><span class="hljs-keyword">if</span> d<span class="hljs-literal">[<span class="hljs-identifier">u</span>]</span>=<span class="hljs-constructor">S(<span class="hljs-params">u</span>,<span class="hljs-params">v</span>)</span><br>   we relax edge(u-v)<br><span class="hljs-keyword">then</span> d<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>=<span class="hljs-constructor">S(<span class="hljs-params">s</span>,<span class="hljs-params">v</span>)</span> after relaxation<br>d<span class="hljs-literal">[<span class="hljs-identifier">v</span>]</span>&gt;=<span class="hljs-constructor">S(<span class="hljs-params">s</span>,<span class="hljs-params">v</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>Bellman-Ford</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">允许负权数的存在<br>d[s]←<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> v ∈V-&#123;s&#125;<br>    <span class="hljs-keyword">do</span> d[v]←∞<br><span class="hljs-keyword">for</span> i←<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> |V|<span class="hljs-number">-1</span><br>    <span class="hljs-keyword">do</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> edge (u,v)∈E<br>       <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> d[v]&gt;d[u]+w(u,v)<br>          <span class="hljs-keyword">then</span> d[v]=d[u]+w(u,v)<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> edge (u,v) ∈E<br>   <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> d[v]&gt;d[u]+w(u,v)<br>      <span class="hljs-keyword">then</span> report that a negative-weight <span class="hljs-keyword">cycle</span> exist<br><span class="hljs-keyword">else</span> d[v]=S(s,v)<br><span class="hljs-type">Time</span>=O(VE)<br></code></pre></td></tr></table></figure></li></ul><h3 id="DFS和BFS"><a href="#DFS和BFS" class="headerlink" title="DFS和BFS"></a>DFS和BFS</h3><ul><li><p>DFS</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">def dfs(graph, <span class="hljs-literal">start</span>):<br>    <span class="hljs-comment"># 创建一个栈用来存储待访问的节点</span><br>    stack = [<span class="hljs-literal">start</span>]<br>    <span class="hljs-comment"># 创建一个集合用来存储已访问过的节点</span><br>    visited = set()<br><br>    while stack:<br>        <span class="hljs-comment"># 从栈中取出一个节点</span><br>        <span class="hljs-keyword">node</span> <span class="hljs-title">= stack</span>.pop()<br>        <span class="hljs-comment"># 如果该节点已经访问过，则跳过</span><br>        if <span class="hljs-keyword">node</span> <span class="hljs-title">in</span> visited:<br>            continue<br>        <span class="hljs-comment"># 将节点标记为已访问</span><br>        visited.add(<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">        # 打印访问的节点（或者进行其他操作）</span><br><span class="hljs-title">        print</span>(<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">        # 将该节点的邻居节点加入栈中</span><br><span class="hljs-title">        for</span> neighbor <span class="hljs-keyword">in</span> graph[<span class="hljs-keyword">node</span><span class="hljs-title">]:</span><br><span class="hljs-title">            if</span> neighbor not <span class="hljs-keyword">in</span> visited:<br>                stack.append(neighbor)<br></code></pre></td></tr></table></figure></li><li><p>BFS</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">from collections import deque<br><br>def bfs(graph, <span class="hljs-literal">start</span>):<br>    <span class="hljs-comment"># 创建一个队列用来存储待访问的节点</span><br>    queue = deque([<span class="hljs-literal">start</span>])<br>    <span class="hljs-comment"># 创建一个集合用来存储已访问过的节点</span><br>    visited = set()<br><br>    while queue:<br>        <span class="hljs-comment"># 从队列中取出一个节点</span><br>        <span class="hljs-keyword">node</span> <span class="hljs-title">= queue</span>.popleft()<br>        <span class="hljs-comment"># 如果该节点已经访问过，则跳过</span><br>        if <span class="hljs-keyword">node</span> <span class="hljs-title">in</span> visited:<br>            continue<br>        <span class="hljs-comment"># 将节点标记为已访问</span><br>        visited.add(<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">        # 打印访问的节点（或者进行其他操作）</span><br><span class="hljs-title">        print</span>(<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">        # 将该节点的邻居节点加入队列中</span><br><span class="hljs-title">        for</span> neighbor <span class="hljs-keyword">in</span> graph[<span class="hljs-keyword">node</span><span class="hljs-title">]:</span><br><span class="hljs-title">            if</span> neighbor not <span class="hljs-keyword">in</span> visited:<br>                queue.append(neighbor)<br></code></pre></td></tr></table></figure></li></ul><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><ul><li><p>算法名称</p><p>有两种表示算法的伪代码：<br>过程（Procedure）<br>函数（Function）<br>过程和函数的区别是：<br>过程是执行一系列操作，不需要返回操作的结果，无返回数据。<br>函数是执行一系列的操作后，要将操作的结果返回，有返回数据。<br>简单来说二者就是<strong>有没有返回数据</strong>。<br>算法伪代码的书写规则：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">Procedure</span> &lt;算法名&gt;<span class="hljs-params">([&lt;参数列表&gt;])</span></span><br><span class="hljs-function"><span class="hljs-title">Function</span> &lt;算法名&gt;<span class="hljs-params">([&lt;参数列表&gt;])</span></span><br></code></pre></td></tr></table></figure></li><li><p>指令序列</p><p>指令序列是算法的主体。<br>指令序列的书写规则：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Begin</span><br>指令序列;<br><span class="hljs-keyword">End</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&#123;<br>指令序列<span class="hljs-comment">;</span><br>/&#125;<br></code></pre></td></tr></table></figure></li><li><p>输入和输出</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">输入：<span class="hljs-keyword">Input</span><br>输出：<span class="hljs-keyword">Output</span> 或<span class="hljs-keyword">Return</span><br></code></pre></td></tr></table></figure></li><li><p>分支选择</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>第一种<br>If&lt;条件&gt; Then<br>&#123;<br>指令序列;<br>/&#125;<br><span class="hljs-regexp">//</span>第二种<br>If&lt;条件&gt; Then<br>&#123;<br>指令序列<span class="hljs-number">1</span>;<br>/&#125;<br>Else<br>&#123;<br>指令序列<span class="hljs-number">2</span>;<br>/&#125;<br></code></pre></td></tr></table></figure></li><li><p>赋值</p><p>有两种 可以用<code>:=</code>或者<code>&lt;-</code>作为赋值操作符，相当于C语言中的<code>=</code><br>例如：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">x:</span><span class="hljs-operator">=</span><span class="hljs-keyword">x</span><span class="hljs-number">+1</span><span class="hljs-comment">;</span><br><span class="hljs-keyword">x</span>&lt;-<span class="hljs-keyword">x</span><span class="hljs-number">+1</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li><p>循环</p><p>两种方式：计数式循环（for循环）和条件式循环（while循环）。<br>（1）计数式循环</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">For 变量：<span class="hljs-operator">=</span>初值 To 终值<br>&#123;<br>指令序列<span class="hljs-comment">;</span><br>/&#125;<br></code></pre></td></tr></table></figure><p>（2）条件式循环</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-keyword">While</span> <span class="hljs-comment">(条件)</span> <span class="hljs-keyword">do</span><br>&#123;<br>指令序列;<br>/&#125;<br></code></pre></td></tr></table></figure></li><li><p>算法结束</p><p>关键字End的后面加上算法名称，表示算法结束，是算法的最后一句。<br>例如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">End</span> DFS<br></code></pre></td></tr></table></figure></li><li><p>补充<br>除了这些，像运算符号* &#x2F; + - %等等，都是和C语言用法一样<br>数组：<br>A[j]指示数组A的第j个元素。符号“ …”用来指示数组中值的范围。例如：<br>A[1…j]表示含元素A[1], A[2], … , A[j]的子数组；<br>还有个写法是A[0:n]表示数组下标从0开始一直到n<br>二维数组也是：A[0:m,0:n]</p></li><li><p>例子</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">procedure</span> <span class="hljs-title function_">Bubble</span><span class="hljs-params">(n:integer)</span>;<br>  <span class="hljs-keyword">var</span> temp,i,j:integer<span class="hljs-punctuation">;</span><br>  change:boolean<span class="hljs-punctuation">;</span><br>  <span class="hljs-keyword">begin</span><br>     <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n-<span class="hljs-number">1</span> <span class="hljs-keyword">do</span><br>     <span class="hljs-keyword">begin</span><br>       change:=<span class="hljs-keyword">false</span><span class="hljs-punctuation">;</span><br>       <span class="hljs-keyword">for</span> j:=n-<span class="hljs-number">1</span> <span class="hljs-keyword">downto</span> i <span class="hljs-keyword">do</span><br>         <span class="hljs-keyword">if</span> a[j]&gt;a[j+<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br>         <span class="hljs-keyword">begin</span><br>           change:=<span class="hljs-keyword">true</span><span class="hljs-punctuation">;</span><br>           temp:=a[j]<span class="hljs-punctuation">;</span> a[j]:=a[j+<span class="hljs-number">1</span>]<span class="hljs-punctuation">;</span> a[j+<span class="hljs-number">1</span>]:=temp<span class="hljs-punctuation">;</span><br>         <span class="hljs-keyword">end</span><span class="hljs-punctuation">;</span><br>         <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span>(change) <span class="hljs-keyword">then</span> <span class="hljs-keyword">exit</span><span class="hljs-punctuation">;</span><br>     <span class="hljs-keyword">end</span><span class="hljs-punctuation">;</span><br>  <span class="hljs-keyword">end</span><span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>它来自旅途的尽头，世界的边缘。来自你我心中，永不停歇</p></blockquote><img src="/img/Y1.webp" style="zoom:50%;" />     ]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些奇奇怪怪的东西</title>
    <link href="/2023/10/02/test/"/>
    <url>/2023/10/02/test/</url>
    
    <content type="html"><![CDATA[<h4 id="std-ios-sync-with-stdio"><a href="#std-ios-sync-with-stdio" class="headerlink" title="std::ios::sync_with_stdio"></a>std::ios::sync_with_stdio</h4><p>std::ios::sync_with_stdio是一个用于设置C++的标准输入输出流与C标准库输入输出流的同步的方法。</p><p>默认情况下，C++的输入输出流（如std::cin和std::cout）与C标准库的输入输出流（如scanf和printf）是独立的，它们使用不同的缓冲区，因此在使用它们时可能会发生混乱。</p><p>当调用std::ios::sync_with_stdio(true)时，C++的输入输出流会与C标准库的输入输出流同步，这意味着它们将共享相同的缓冲区，从而避免了混乱。</p><p>但是，由于同步会导致性能上的损失，因此在竞赛或需要高性能的场景下，通常会将std::ios::sync_with_stdio(false)以禁用同步。</p><hr><h4 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h4><p>在C++中，scanf函数是用于从标准输入流中读取输入的函数。它可以根据指定的格式字符串将输入解析为不同的数据类型。</p><p>以下是一些关于scanf函数的重要事项：</p><ul><li><p>格式字符串：scanf函数使用格式字符串来指定输入的格式。格式字符串包含了各种格式指示符，如%d表示整数，%f表示浮点数，%s表示字符串等。可以在格式字符串中- 使用空格、制表符和换行符来跳过输入中的空白字符。</p></li><li><p>输入变量：scanf函数使用变量的地址作为参数来接收输入的值。例如，scanf(“%d”, &amp;num)将从输入中读取一个整数，并将其存储在num变量中。</p></li><li><p>返回值：scanf函数返回成功读取的输入项数。如果返回值小于参数的数量，则可能是由于输入格式与指定的格式字符串不匹配或输入结束引起的。</p></li><li><p>输入控制：scanf函数会等待用户输入，直到满足指定格式的输入可用。它可以使用空格、制表符和换行符来跳过输入中的空白字符。</p></li><li><p>输入错误处理：scanf函数可以处理输入错误，如无效的输入格式或输入超出变量的范围。可以使用返回值来检查是否发生了输入错误，并使用fflush(stdin)函数清除输入缓冲区。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">float</span> f;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">100</span>];<br><br>    <span class="hljs-comment">// 从输入中读取一个整数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入一个整数：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入的整数是：%d\n&quot;</span>, num);<br><br>    <span class="hljs-comment">// 从输入中读取一个浮点数</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入一个浮点数：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%f&quot;</span>, &amp;f);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="pragma-comment"><a href="#pragma-comment" class="headerlink" title="pragma comment"></a>pragma comment</h4><p>pragma comment (linker,”&#x2F;stack:102400000,102400000”) 是一个用于设置链接器选项的预处理指令。它用于指定程序运行时的堆栈大小。</p><p>这个指令的参数是一个字符串，其中包含两个整数值，用逗号分隔。第一个整数值表示程序的初始堆栈大小，第二个整数值表示堆栈的最大大小。在上述示例中，堆栈大小被设置为 102400000 字节（即100 MB），并且最大堆栈大小也是 102400000 字节。</p><p>通过设置堆栈大小，可以确保程序在运行时有足够的堆栈空间来处理递归调用或大量的局部变量。但是，设置过大的堆栈大小可能会导致内存浪费，因此需要根据实际需求进行调整。</p><hr><h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p>在宏定义中，# 是一个预处理操作符，称为字符串化操作符（stringizing operator）。它的作用是将宏的参数转换为字符串常量。在这里，#x 将参数 x 转换为一个字符串。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">include &lt;iostream&gt;<br><br><span class="hljs-function">define <span class="hljs-title">str</span><span class="hljs-params">(x)</span> <span class="hljs-meta">#x</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">10</span>;<br>    std::cout &lt;&lt; <span class="hljs-built_in">str</span>(num) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">str</span>(Hello World) &lt;&lt; std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>在上述示例中，<span class="hljs-built_in">str</span>(num) 会被替换为 <span class="hljs-string">&quot;num&quot;</span>，<span class="hljs-built_in">str</span>(Hello World) 会被替换为 <span class="hljs-string">&quot;Hello World&quot;</span>。这样，std::cout 语句将输出这些字符串。<br></code></pre></td></tr></table></figure><hr><h4 id="getchar"><a href="#getchar" class="headerlink" title="getchar()"></a><code>getchar()</code></h4><p><code>getchar()</code> 是一个C++中的标准函数，用于从标准输入流中读取一个字符。它的作用是获取输入流中的下一个字符，并将其返回为一个整数。在这种情况下，<code>getchar()</code> 的作用是读取输入流中的换行符（或回车符），以清除输入缓冲区中的剩余字符。</p><p>在使用 <code>cin</code> 来读取输入时，如果在读取完一个数据后直接使用 <code>getchar()</code> 来读取换行符，可以避免在后续的输入操作中出现意外的问题。因为在输入数据时，用户通常会按下回车键来确认输入，回车键会产生一个换行符，而 <code>cin</code> 只会读取数据部分，不会读取换行符。如果不使用 <code>getchar()</code> 来读取换行符，那么下一次读取输入时，换行符会被当作有效输入，导致程序出现错误。</p><p>综上所述，<code>getchar()</code> 的作用是读取输入流中的换行符，以确保后续的输入操作能够正常进行。</p><hr><h4 id="asm-volatile-“cli”"><a href="#asm-volatile-“cli”" class="headerlink" title="asm volatile (“cli”)"></a>asm volatile (“cli”)</h4><p>代码”asm volatile (“cli”)”是C语言中的内联汇编代码。</p><p>“asm”关键字用于表示以下代码是内联汇编代码，即用汇编语言编写的代码。</p><p>“volatile”关键字用于告知编译器该代码具有副作用，不应进行优化或删除。在这种情况下，它确保”cli”指令不会被编译器优化掉。</p><p>“cli”指令是一条汇编语言指令，表示”清除中断标志位”。它禁用处理器上的中断，阻止其被处理。这条指令通常在操作系统内核或代码的关键部分中使用，用于临时禁用中断以确保原子性或避免竞态条件。</p><hr><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><p>操作系统由以下几个主要组成部分构成：</p><ol><li><p>内核（Kernel）：内核是操作系统的核心部分，负责管理系统资源、提供基本的服务和功能。它控制计算机硬件并提供给应用程序访问硬件的接口。内核管理进程、内存、文件系统、设备驱动程序等。</p></li><li><p>文件系统（File System）：文件系统是操作系统用于组织和管理文件和目录的一种方式。它定义了文件和目录的结构、访问权限、存储方式等。文件系统提供了对文件的读写、创建、删除等操作。</p></li><li><p>进程管理（Process Management）：进程管理是操作系统负责管理和调度进程（程序的执行实例）的部分。它控制进程的创建、调度、终止，并提供进程间通信和同步机制。</p></li><li><p>内存管理（Memory Management）：内存管理是操作系统负责管理计算机内存的部分。它负责分配和回收内存空间，并提供虚拟内存机制、内存保护、内存映射等功能。</p></li><li><p>设备驱动程序（Device Drivers）：设备驱动程序是操作系统中用于控制和管理硬件设备的软件模块。它提供了对硬件设备的访问接口，使操作系统能够与硬件设备进行通信。</p></li><li><p>用户界面（User Interface）：用户界面是操作系统与用户之间进行交互的部分。它可以是命令行界面（如终端），也可以是图形用户界面（如窗口系统），还可以是其他形式的交互方式。</p></li></ol><p>这些组成部分共同协作，使得操作系统能够有效地管理计算机资源、提供服务，并为应用程序提供一个可靠和友好的运行环境。</p><hr><h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><p>在32位的x86体系结构中，段寄存器是一组特殊的寄存器，用于存储段选择子（Segment Selector）。每个段选择子是一个16位的值，它包含了描述一个内存段的信息，包括段的起始地址、大小、访问权限等。段寄存器的作用是存储这些段选择子，以便操作系统和处理器能够正确地访问和管理内存。</p><p>具体来说，x86体系结构中有以下几个段寄存器：</p><p>CS（Code Segment Register）：存储当前正在执行的代码所在的代码段的选择子。</p><ul><li>15-3位：段选择子的索引，用于在全局描述符表（Global Descriptor Table，GDT）或局部描述符表（Local Descriptor Table，LDT）中查找对应的段描述符。</li><li>2-0位：特权级（Privilege Level），用于确定代码段的访问权限。</li></ul><p>DS（Data Segment Register）：存储当前访问数据的数据段的选择子。</p><p>SS（Stack Segment Register）：存储当前栈操作的栈段的选择子。</p><p>ES（Extra Segment Register）：存储其他数据操作的额外数据段的选择子。</p><p>FS 和 GS（Additional Segment Registers）：这两个寄存器是用于提供额外的数据段选择子，用于一些特殊用途。</p><p>当处理器需要访问内存时，它会使用相应的段寄存器中存储的选择子来确定要访问的内存段。选择子中的段基址会与偏移地址进行计算，从而得到实际的物理地址。</p><p>段寄存器的工作原理是通过选择子来确定要访问的内存段，以实现内存的分段管理和保护。操作系统可以通过修改段寄存器的值来切换不同的内存段，从而控制不同程序的内存访问权限和地址空间。</p><hr><h4 id="CR0和CR3是x86架构中的控制寄存器。"><a href="#CR0和CR3是x86架构中的控制寄存器。" class="headerlink" title="CR0和CR3是x86架构中的控制寄存器。"></a>CR0和CR3是x86架构中的控制寄存器。</h4><p>CR0（Control Register 0）：CR0是控制寄存器之一，用于控制处理器的运行模式和一些基本的系统特性。它包含了一系列的位字段，用于控制处理器的保护模式、分页机制、浮点协处理器的使用等。CR0中的一些重要位字段包括：</p><ul><li>PE（Protection Enable）：启用保护模式。</li><li>PG（Paging）：启用分页机制。</li><li>WP（Write Protect）：启用写保护模式，防止特权级别低的代码写入只读页面。</li><li>NE（Numeric Error）：启用浮点协处理器异常的处理。</li><li>TS（Task Switched）：指示处理器是否在任务切换状态。</li></ul><p>CR3（Control Register 3）：CR3是控制寄存器之一，用于存储页表的物理地址。在启用分页机制时，CR3中存储的是当前进程的页目录表的物理地址。通过修改CR3的值，可以切换不同的页表，实现进程间的内存隔离和虚拟地址映射。CR3中的一些重要位字段包括：</p><ul><li>PWT（Page-Level Write-Through）：页级写透模式，控制页表是否使用写透模式。</li><li>PCD（Page-Level Cache Disable）：页级缓存禁用，控制页表是否使用缓存。</li><li>PCID（Process Context Identifier）：进程上下文标识符，用于快速切换页表。</li></ul><p>通过修改CR0和CR3的值，可以控制处理器的运行模式、内存分页机制和页表的切换，从而实现对系统的控制和管理。</p><hr><p>assert的作用是用于断言某个条件是否为真，如果条件为假，则终止程序的执行并打印错误信息。在上面的代码中，assert(ps)用于判断指针ps是否为空，如果为空则终止程序的执行并打印错误信息。</p><hr><h4 id="realloc"><a href="#realloc" class="headerlink" title="realloc()"></a>realloc()</h4><p>C语言 realloc() 函数位于 stdlib.h 头文件中，其原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">realloc</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> size)</span>;<br></code></pre></td></tr></table></figure><p>realloc() 会将 ptr 所指向的内存块的大小修改为 size，并将新的内存指针返回。</p><p>设之前内存块的大小为 n，如果 size &lt; n，那么截取的内容不会发生变化，如果 size &gt; n，那么新分配的内存不会被初始化。</p><ol><li>如果 ptr &#x3D; NULL，那么相当于调用 malloc(size)；如果 size &#x3D; 0，那么相当于调用 free(ptr)。</li><li>如果 ptr 不为 NULL，那么他肯定是由之前的内存分配函数返回的，例如 malloc()、calloc()或realloc()。</li><li>如果 ptr 所指的内存块被移动，那么会调用 free(ptr)。</li></ol><hr><h4 id="std-istringstream"><a href="#std-istringstream" class="headerlink" title="std::istringstream"></a><code>std::istringstream</code></h4><p><code>std::istringstream</code>是C++中的一个输入字符串流类，它可以用于从字符串中提取数据。您可以使用<code>std::istringstream</code>来将字符串拆分为数字和其他数据类型。</p><p>以下是<code>std::istringstream</code>的基本用法示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str = <span class="hljs-string">&quot;123 45.6 hello&quot;</span>;<br>    <span class="hljs-function">std::istringstream <span class="hljs-title">iss</span><span class="hljs-params">(str)</span></span>;<br>    <br>    <span class="hljs-type">int</span> num1;<br>    <span class="hljs-type">float</span> num2;<br>    std::string word;<br>    <br>    iss &gt;&gt; num1 &gt;&gt; num2 &gt;&gt; word;<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Number 1: &quot;</span> &lt;&lt; num1 &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Number 2: &quot;</span> &lt;&lt; num2 &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Word: &quot;</span> &lt;&lt; word &lt;&lt; std::endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们首先创建了一个包含数字、浮点数和字符串的字符串<code>str</code>。然后，我们使用<code>std::istringstream</code>类将字符串<code>str</code>绑定到输入流<code>iss</code>上。接下来，我们使用<code>iss</code>从字符串中提取数据，并将它们存储在相应的变量<code>num1</code>、<code>num2</code>和<code>word</code>中。最后，我们输出这些变量的值。</p><p>输出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Number</span> <span class="hljs-number">1</span>: <span class="hljs-number">123</span><br><span class="hljs-attribute">Number</span> <span class="hljs-number">2</span>: <span class="hljs-number">45</span>.<span class="hljs-number">6</span><br><span class="hljs-attribute">Word</span>: hello<br></code></pre></td></tr></table></figure><p>通过使用<code>&gt;&gt;</code>运算符，<code>std::istringstream</code>可以将字符串中的数据提取到不同的变量中。在提取数据时，<code>&gt;&gt;</code>运算符会自动忽略空格和换行符。</p><hr><h4 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h4><p>在C++中，可以使用std::cin来输入包含空格的字符数组。以下是一个示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">100</span>;<br>    <span class="hljs-type">char</span> input[SIZE];<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;请输入一个包含空格的字符串：&quot;</span>;<br>    std::cin.<span class="hljs-built_in">getline</span>(input, SIZE);<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;输入的字符串是：&quot;</span> &lt;&lt; input &lt;&lt; std::endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，使用了std::cin.getline()函数来获取用户输入的一行字符串，包括空格。输入的字符串将被存储在名为input的字符数组中。需要注意的是，需要指定字符数组的大小，以确保输入的字符串不会超出数组的容量。</p><p>string input;<br>输入包含的空格的字符串则可以用getline(cin,input);</p><hr><h4 id="和"><a href="#和" class="headerlink" title="*和&amp;"></a><code>*</code>和<code>&amp;</code></h4><p>在C++中，<code>*</code>和<code>&amp;</code>符号有以下含义：</p><ol><li><p><code>*</code>符号：</p><ul><li>在声明变量时，<code>*</code>用于定义指针类型。例如，<code>int* ptr;</code>声明了一个指向<code>int</code>类型的指针变量<code>ptr</code>。</li><li>在指针变量前使用<code>*</code>运算符，可以获取指针所指向的值。例如，<code>int x = *ptr;</code>将获取<code>ptr</code>指针所指向的<code>int</code>值，并将其赋给变量<code>x</code>。</li><li>在函数参数中，<code>*</code>用于定义指针类型的形参。例如，<code>void foo(int* ptr)</code>定义了一个接受指向<code>int</code>类型的指针作为参数的函数<code>foo</code>。</li></ul></li><li><p><code>&amp;</code>符号：</p><ul><li>在声明变量时，<code>&amp;</code>用于定义引用类型。例如，<code>int x = 5; int&amp; ref = x;</code>声明了一个引用变量<code>ref</code>，它引用了变量<code>x</code>。</li><li>在变量前使用<code>&amp;</code>运算符，可以获取变量的地址。例如，<code>int* ptr = &amp;x;</code>将获取变量<code>x</code>的地址，并将其赋给指针变量<code>ptr</code>。</li><li>在函数参数中，<code>&amp;</code>用于定义引用类型的形参。例如，<code>void foo(int&amp; ref)</code>定义了一个接受引用类型的参数的函数<code>foo</code>。</li></ul></li></ol><hr><h4 id="解决了typora和博客无法显示图片的问题"><a href="#解决了typora和博客无法显示图片的问题" class="headerlink" title="解决了typora和博客无法显示图片的问题"></a>解决了typora和博客无法显示图片的问题</h4><p>我是采用fluid为主题</p><ol><li><p>typora方面：点击格式-&gt;图像-&gt;设置图片根目录-&gt;将图片根目录设置为theme&#x2F;fluid&#x2F;source&#x2F;img</p></li><li><p>将要插入的本地图片放入theme&#x2F;fluid&#x2F;source&#x2F;img</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">![](<span class="hljs-regexp">/img/</span>example.jpg)<br></code></pre></td></tr></table></figure><p>插入图片语法如上图所示，这样typora和博客就都能显示图片了</p></li></ol><h4 id="镜像文件显示在System中打开如何删除"><a href="#镜像文件显示在System中打开如何删除" class="headerlink" title="镜像文件显示在System中打开如何删除"></a>镜像文件显示在System中打开如何删除</h4><p>1.首先进入计算机磁盘存储页面。<br>2.然后右键单击驱动器，在弹出页面中选择“弹出”选项。<br>3.当CD驱动器显示弹出时，可以删除要删除的文件。<br>4.右键单击并选择“删除”，然后在弹出界面中选择“是”选项。<br>5.最后可以看到删除的文件已经在计算机的［回收站］中。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>git和markdown</title>
    <link href="/2023/10/02/git%E5%92%8Cmarkdown/"/>
    <url>/2023/10/02/git%E5%92%8Cmarkdown/</url>
    
    <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><ul><li>列表项 1</li><li>列表项 2</li></ul><ol><li>有序列表项 1</li><li>有序列表项 2</li></ol><p><strong>粗体文本</strong></p><p><em>斜体文本</em></p><p><code>代码块</code></p><p><a href="https://example.com/">链接文本</a></p><p><img src="/image.jpg" alt="图像描述"></p><p>简易的命令行入门教程:<br>Git 全局设置:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;casesic&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;2083733118@qq.com&quot;</span><br></code></pre></td></tr></table></figure><p>创建 git 仓库:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">mkdir</span> <span class="hljs-meta">data</span>-structure<br><span class="hljs-symbol">cd</span> <span class="hljs-meta">data</span>-structure<br><span class="hljs-symbol">git</span> init <br><span class="hljs-symbol">touch</span> README.md<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> README.md<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;first commit&quot;</span><br><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//gitee.com/casesic/data-structure.git</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> -u origin <span class="hljs-string">&quot;master&quot;</span><br></code></pre></td></tr></table></figure><p>已有仓库?</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd existing_git_repo<br>git remote add origin https:<span class="hljs-regexp">//gi</span>tee.com<span class="hljs-regexp">/casesic/</span>data-structure.git<br>git push -u origin <span class="hljs-string">&quot;master&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>image-change</title>
    <link href="/2023/10/02/image-change/"/>
    <url>/2023/10/02/image-change/</url>
    
    <content type="html"><![CDATA[<img src="/2023/10/02/image-change/pika.jpg" class="" title="This is an image"><blockquote><p>每天快乐的睡觉</p></blockquote><h2 id="图像的二维变换"><a href="#图像的二维变换" class="headerlink" title="图像的二维变换"></a>图像的二维变换</h2><ol><li><p>图像滤波(改变图片亮度)</p></li><li><p>图像变形(改变图片位置)</p><div align=center><img src="S1.png" width = 65%></div></li><li><p>图像放大或缩小</p></li></ol><div align=center><img src="S2.png" width = 65%></div><ol start="4"><li>图像旋转</li></ol><div align=center><img src="S3.png" width = 65%></div><ol start="5"><li>图像倾斜</li></ol><div align=center><img src="S4.png" width = 65%></div><ol start="6"><li>镜像图片</li></ol><div align=center><img src="S5.png" width = 65%></div><h2 id="图像的三维变换"><a href="#图像的三维变换" class="headerlink" title="图像的三维变换"></a>图像的三维变换</h2><ol><li><p>图像的二维变化在三维变化中的表示</p><div align=center><img src="C1.png" width = 65%></div></li><li><p>放射变换</p></li></ol><ul><li>变换的三维举证如下图 <div align=center><img src="C5.png" width = 65%></div></li><li>性质<br>原点不一定映射到原点<br>直线映射到直线<br>平行线依旧保持平行<br>在构图下保持闭合</li></ul><ol start="3"><li>投影变换(单应性变换)<div align=center><img src="C3.png" width = 65%></div></li></ol><ul><li>性质<br>原点不一定映射到原点<br>直线映射到直线<br>平行线不一定保持平行<br>保持闭合</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a></h2><hr><blockquote><p>hahaha,祝大家天天开心</p></blockquote><img src="/2023/10/02/image-change/plane.png" class="" title="This is an image">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/10/02/hello-world/"/>
    <url>/2023/10/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
